From 007e40b5f8e8fc2c88efef0ea79b48ce81c0aca0 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sat, 1 Mar 2025 15:27:54 +0200
Subject: [PATCH 01/37] ntdll: Enable esync and fsync by default.

---
 dlls/ntdll/unix/esync.c | 2 +-
 dlls/ntdll/unix/fsync.c | 2 +-
 server/esync.c          | 2 +-
 server/fsync.c          | 2 +-
 4 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 3074f7c72ea..ec3aff489a5 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -57,7 +57,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync();
+        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync();
 
     return do_esync_cached;
 #else
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index ebd71ea3b7c..beebe520e4c 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -171,7 +171,7 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, NULL, 0, 0, NULL, 0 );
-        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+        do_fsync_cached = !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) && errno != ENOSYS;
     }
 
     return do_fsync_cached;
diff --git a/server/esync.c b/server/esync.c
index a5164435ed6..d6057d1a45c 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -51,7 +51,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync();
+        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync();
 
     return do_esync_cached;
 #else
diff --git a/server/fsync.c b/server/fsync.c
index dc50aa0a1f3..b83cdc10a51 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -59,7 +59,7 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, 0, 0, 0, 0, 0);
-        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+        do_fsync_cached = !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) && errno != ENOSYS;
     }
 
     return do_fsync_cached;
-- 
2.49.0


From e4f46c4fb22128f41ccdb78bece5744e82e54636 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 22:31:06 +0200
Subject: [PATCH 02/37] server: Add an object operation to retrieve an
 in-process synchronization object.

---
 server/async.c      |  2 ++
 server/atom.c       |  1 +
 server/change.c     |  1 +
 server/clipboard.c  |  1 +
 server/completion.c |  2 ++
 server/console.c    |  7 +++++++
 server/debugger.c   |  2 ++
 server/device.c     |  4 ++++
 server/directory.c  |  2 ++
 server/esync.c      |  1 +
 server/event.c      |  2 ++
 server/fd.c         |  4 ++++
 server/file.c       |  1 +
 server/fsync.c      |  1 +
 server/handle.c     |  1 +
 server/hook.c       |  1 +
 server/mailslot.c   |  4 ++++
 server/mapping.c    |  3 +++
 server/mutex.c      |  1 +
 server/named_pipe.c |  6 ++++++
 server/object.c     |  8 ++++++++
 server/object.h     |  8 +++++++-
 server/process.c    |  3 +++
 server/protocol.def | 11 +++++++++++
 server/queue.c      |  2 ++
 server/registry.c   |  1 +
 server/request.c    |  1 +
 server/semaphore.c  |  1 +
 server/serial.c     |  1 +
 server/signal.c     |  1 +
 server/sock.c       |  3 +++
 server/symlink.c    |  1 +
 server/thread.c     |  3 +++
 server/timer.c      |  1 +
 server/token.c      |  1 +
 server/window.c     |  1 +
 server/winstation.c |  2 ++
 37 files changed, 95 insertions(+), 1 deletion(-)

diff --git a/server/async.c b/server/async.c
index 10089b20a0e..bda3021d06f 100644
--- a/server/async.c
+++ b/server/async.c
@@ -92,6 +92,7 @@ static const struct object_ops async_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     async_destroy              /* destroy */
 };
@@ -714,6 +715,7 @@ static const struct object_ops iosb_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     iosb_destroy              /* destroy */
 };
diff --git a/server/atom.c b/server/atom.c
index 6b95a546597..25d7f6041c2 100644
--- a/server/atom.c
+++ b/server/atom.c
@@ -93,6 +93,7 @@ static const struct object_ops atom_table_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     atom_table_destroy            /* destroy */
 };
diff --git a/server/change.c b/server/change.c
index ea551676c25..f5129001836 100644
--- a/server/change.c
+++ b/server/change.c
@@ -126,6 +126,7 @@ static const struct object_ops dir_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --git a/server/clipboard.c b/server/clipboard.c
index a2e0af2ba32..5e709842712 100644
--- a/server/clipboard.c
+++ b/server/clipboard.c
@@ -90,6 +90,7 @@ static const struct object_ops clipboard_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     clipboard_destroy             /* destroy */
 };
diff --git a/server/completion.c b/server/completion.c
index 4c5d2f79bc1..e2fd3b39924 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -110,6 +110,7 @@ static const struct object_ops completion_wait_ops =
     NULL,                           /* unlink_name */
     no_open_file,                   /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                /* close_handle */
     completion_wait_destroy         /* destroy */
 };
@@ -193,6 +194,7 @@ static const struct object_ops completion_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     completion_close_handle,   /* close_handle */
     completion_destroy         /* destroy */
 };
diff --git a/server/console.c b/server/console.c
index 58ec10fa856..530ee31581f 100644
--- a/server/console.c
+++ b/server/console.c
@@ -97,6 +97,7 @@ static const struct object_ops console_ops =
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -180,6 +181,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -251,6 +253,7 @@ static const struct object_ops screen_buffer_ops =
     NULL,                             /* unlink_name */
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
@@ -302,6 +305,7 @@ static const struct object_ops console_device_ops =
     default_unlink_name,              /* unlink_name */
     console_device_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     no_destroy                        /* destroy */
 };
@@ -341,6 +345,7 @@ static const struct object_ops console_input_ops =
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -400,6 +405,7 @@ static const struct object_ops console_output_ops =
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -460,6 +466,7 @@ static const struct object_ops console_connection_ops =
     default_unlink_name,              /* unlink_name */
     console_connection_open_file,     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     console_connection_close_handle,  /* close_handle */
     console_connection_destroy        /* destroy */
 };
diff --git a/server/debugger.c b/server/debugger.c
index 5494eb517df..249c530e9b1 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -100,6 +100,7 @@ static const struct object_ops debug_event_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     debug_event_destroy            /* destroy */
 };
@@ -130,6 +131,7 @@ static const struct object_ops debug_obj_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
diff --git a/server/device.c b/server/device.c
index 20950f50710..78a37ae3bc0 100644
--- a/server/device.c
+++ b/server/device.c
@@ -82,6 +82,7 @@ static const struct object_ops irp_call_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     irp_call_destroy                  /* destroy */
 };
@@ -128,6 +129,7 @@ static const struct object_ops device_manager_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -187,6 +189,7 @@ static const struct object_ops device_ops =
     default_unlink_name,              /* unlink_name */
     device_open_file,                 /* open_file */
     device_get_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     device_destroy                    /* destroy */
 };
@@ -241,6 +244,7 @@ static const struct object_ops device_file_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
diff --git a/server/directory.c b/server/directory.c
index cd17883458e..1e3f71d6e81 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -83,6 +83,7 @@ static const struct object_ops object_type_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     no_destroy                    /* destroy */
 };
@@ -135,6 +136,7 @@ static const struct object_ops directory_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     directory_destroy             /* destroy */
 };
diff --git a/server/esync.c b/server/esync.c
index d6057d1a45c..586ecc08059 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -143,6 +143,7 @@ const struct object_ops esync_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     esync_destroy              /* destroy */
 };
diff --git a/server/event.c b/server/event.c
index be120695e6e..e6c86472c71 100644
--- a/server/event.c
+++ b/server/event.c
@@ -93,6 +93,7 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     event_destroy              /* destroy */
 };
@@ -142,6 +143,7 @@ static const struct object_ops keyed_event_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
+    no_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     no_destroy                   /* destroy */
 };
diff --git a/server/fd.c b/server/fd.c
index 47c7ec7ee9a..5d99eedd340 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -185,6 +185,7 @@ static const struct object_ops fd_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     fd_destroy                /* destroy */
 };
@@ -228,6 +229,7 @@ static const struct object_ops device_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     device_destroy            /* destroy */
 };
@@ -270,6 +272,7 @@ static const struct object_ops inode_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     inode_destroy             /* destroy */
 };
@@ -314,6 +317,7 @@ static const struct object_ops file_lock_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --git a/server/file.c b/server/file.c
index 934c394ae34..40ff667c98e 100644
--- a/server/file.c
+++ b/server/file.c
@@ -137,6 +137,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --git a/server/fsync.c b/server/fsync.c
index b83cdc10a51..0fbfc690a66 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -164,6 +164,7 @@ const struct object_ops fsync_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     fsync_destroy              /* destroy */
 };
diff --git a/server/handle.c b/server/handle.c
index 2dca6d8155d..85e90577d48 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -140,6 +140,7 @@ static const struct object_ops handle_table_ops =
     NULL,                            /* unlink_name */
     no_open_file,                    /* open_file */
     no_kernel_obj_list,              /* get_kernel_obj_list */
+    no_get_inproc_sync,              /* get_inproc_sync */
     no_close_handle,                 /* close_handle */
     handle_table_destroy             /* destroy */
 };
diff --git a/server/hook.c b/server/hook.c
index 499b333dc3a..521f28e085f 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -95,6 +95,7 @@ static const struct object_ops hook_table_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     hook_table_destroy            /* destroy */
 };
diff --git a/server/mailslot.c b/server/mailslot.c
index 37f8f1a679c..f89778b924e 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -95,6 +95,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -158,6 +159,7 @@ static const struct object_ops mail_writer_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     mail_writer_destroy         /* destroy */
 };
@@ -225,6 +227,7 @@ static const struct object_ops mailslot_device_ops =
     default_unlink_name,            /* unlink_name */
     mailslot_device_open_file,      /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                /* close_handle */
     mailslot_device_destroy         /* destroy */
 };
@@ -257,6 +260,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
+    no_get_inproc_sync,                     /* get_inproc_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --git a/server/mapping.c b/server/mapping.c
index e68edf8aba4..572d3ba66e7 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -81,6 +81,7 @@ static const struct object_ops ranges_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     ranges_destroy             /* destroy */
 };
@@ -119,6 +120,7 @@ static const struct object_ops shared_map_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     shared_map_destroy         /* destroy */
 };
@@ -196,6 +198,7 @@ static const struct object_ops mapping_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     mapping_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     mapping_destroy              /* destroy */
 };
diff --git a/server/mutex.c b/server/mutex.c
index 2503d12057f..58ac83bd3f7 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -87,6 +87,7 @@ static const struct object_ops mutex_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 2beb590c2cc..ad0c9f549a6 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -136,6 +136,7 @@ static const struct object_ops named_pipe_ops =
     default_unlink_name,          /* unlink_name */
     named_pipe_open_file,         /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     named_pipe_destroy            /* destroy */
 };
@@ -186,6 +187,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -232,6 +234,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -281,6 +284,7 @@ static const struct object_ops named_pipe_device_ops =
     default_unlink_name,              /* unlink_name */
     named_pipe_device_open_file,      /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     named_pipe_device_destroy         /* destroy */
 };
@@ -314,6 +318,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
+    no_get_inproc_sync,                      /* get_inproc_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
@@ -367,6 +372,7 @@ static const struct object_ops named_pipe_dir_ops =
     NULL,                                    /* unlink_name */
     named_pipe_dir_open_file,                /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
+    no_get_inproc_sync,                      /* get_inproc_sync */
     named_pipe_dir_close_handle,             /* close_handle */
     named_pipe_dir_destroy                   /* destroy */
 };
diff --git a/server/object.c b/server/object.c
index 0fc9aef451a..cd5c4dd4ceb 100644
--- a/server/object.c
+++ b/server/object.c
@@ -122,6 +122,7 @@ static const struct object_ops apc_reserve_ops =
     default_unlink_name,        /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -148,6 +149,7 @@ static const struct object_ops completion_reserve_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     no_destroy                 /* destroy */
 };
@@ -643,6 +645,12 @@ struct fd *no_get_fd( struct object *obj )
     return NULL;
 }
 
+struct inproc_sync *no_get_inproc_sync( struct object *obj )
+{
+    set_error( STATUS_OBJECT_TYPE_MISMATCH );
+    return NULL;
+}
+
 unsigned int default_map_access( struct object *obj, unsigned int access )
 {
     return map_access( access, &obj->ops->type->mapping );
diff --git a/server/object.h b/server/object.h
index fb3f3211fae..403dfa3b141 100644
--- a/server/object.h
+++ b/server/object.h
@@ -42,7 +42,7 @@ struct async;
 struct async_queue;
 struct winstation;
 struct object_type;
-
+struct inproc_sync;
 
 struct unicode_str
 {
@@ -107,6 +107,8 @@ struct object_ops
                                 unsigned int options);
     /* return list of kernel objects */
     struct list *(*get_kernel_obj_list)(struct object *);
+    /* get a client-waitable in-process synchronization handle to this object */
+    struct inproc_sync *(*get_inproc_sync)(struct object *);
     /* close a handle to this object */
     int (*close_handle)(struct object *,struct process *,obj_handle_t);
     /* destroy on refcount == 0 */
@@ -235,6 +237,10 @@ extern void reset_event( struct event *event );
 
 extern void abandon_mutexes( struct thread *thread );
 
+/* in-process synchronization functions */
+
+extern struct inproc_sync *no_get_inproc_sync( struct object *obj );
+
 /* serial functions */
 
 int get_serial_async_timeout(struct object *obj, int type, int count);
diff --git a/server/process.c b/server/process.c
index 81ee0be4ee9..5072b400a70 100644
--- a/server/process.c
+++ b/server/process.c
@@ -124,6 +124,7 @@ static const struct object_ops process_ops =
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -177,6 +178,7 @@ static const struct object_ops startup_info_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     startup_info_destroy           /* destroy */
 };
@@ -240,6 +242,7 @@ static const struct object_ops job_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
diff --git a/server/protocol.def b/server/protocol.def
index 72cb633397a..e240c4212db 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4203,6 +4203,17 @@ enum fsync_type
     FSYNC_QUEUE,
 };
 
+enum inproc_sync_type
+{
+    INPROC_SYNC_SEMAPHORE = 1,
+    INPROC_SYNC_MUTEX,
+    INPROC_SYNC_AUTO_EVENT,
+    INPROC_SYNC_MANUAL_EVENT,
+    INPROC_SYNC_AUTO_SERVER,
+    INPROC_SYNC_MANUAL_SERVER,
+    INPROC_SYNC_QUEUE,
+};
+
 /* Create a new futex-based synchronization object */
 @REQ(create_fsync)
     unsigned int access;        /* wanted access rights */
diff --git a/server/queue.c b/server/queue.c
index cb43e56a436..6a28c3daac5 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -197,6 +197,7 @@ static const struct object_ops msg_queue_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -236,6 +237,7 @@ static const struct object_ops thread_input_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     thread_input_destroy          /* destroy */
 };
diff --git a/server/registry.c b/server/registry.c
index 4c683440fea..f1d368ce946 100644
--- a/server/registry.c
+++ b/server/registry.c
@@ -195,6 +195,7 @@ static const struct object_ops key_ops =
     key_unlink_name,         /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_inproc_sync,      /* get_inproc_sync */
     key_close_handle,        /* close_handle */
     key_destroy              /* destroy */
 };
diff --git a/server/request.c b/server/request.c
index 478e1f9cabf..ffa0ccd1c85 100644
--- a/server/request.c
+++ b/server/request.c
@@ -103,6 +103,7 @@ static const struct object_ops master_socket_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     master_socket_destroy          /* destroy */
 };
diff --git a/server/semaphore.c b/server/semaphore.c
index d354892c224..567a922c0ac 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -84,6 +84,7 @@ static const struct object_ops semaphore_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     no_destroy                     /* destroy */
 };
diff --git a/server/serial.c b/server/serial.c
index 2d9b2cd5318..93619ebccde 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -105,6 +105,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --git a/server/signal.c b/server/signal.c
index 802b7f936b9..2f58105452f 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -76,6 +76,7 @@ static const struct object_ops handler_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     handler_destroy           /* destroy */
 };
diff --git a/server/sock.c b/server/sock.c
index 21b4621bb0c..0e0bfd70793 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -485,6 +485,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
@@ -3619,6 +3620,7 @@ static const struct object_ops ifchange_ops =
     NULL,                    /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_inproc_sync,      /* get_inproc_sync */
     no_close_handle,         /* close_handle */
     ifchange_destroy         /* destroy */
 };
@@ -3842,6 +3844,7 @@ static const struct object_ops socket_device_ops =
     default_unlink_name,        /* unlink_name */
     socket_device_open_file,    /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --git a/server/symlink.c b/server/symlink.c
index 27a90d91dff..5a3f35054a2 100644
--- a/server/symlink.c
+++ b/server/symlink.c
@@ -85,6 +85,7 @@ static const struct object_ops symlink_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     symlink_destroy               /* destroy */
 };
diff --git a/server/thread.c b/server/thread.c
index 25b91a9b74a..8fbfd553cc6 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -115,6 +115,7 @@ static const struct object_ops thread_apc_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     thread_apc_destroy          /* destroy */
 };
@@ -159,6 +160,7 @@ static const struct object_ops context_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -212,6 +214,7 @@ static const struct object_ops thread_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
diff --git a/server/timer.c b/server/timer.c
index 53286dbc56c..ca367a6fb7d 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -96,6 +96,7 @@ static const struct object_ops timer_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
diff --git a/server/token.c b/server/token.c
index 31fc4b8ddc6..16f74a32cae 100644
--- a/server/token.c
+++ b/server/token.c
@@ -164,6 +164,7 @@ static const struct object_ops token_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     token_destroy              /* destroy */
 };
diff --git a/server/window.c b/server/window.c
index 9ac827bfe4e..2f2faaa4081 100644
--- a/server/window.c
+++ b/server/window.c
@@ -121,6 +121,7 @@ static const struct object_ops window_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     window_destroy            /* destroy */
 };
diff --git a/server/winstation.c b/server/winstation.c
index 5a83171e659..a8a0d2b7125 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -90,6 +90,7 @@ static const struct object_ops winstation_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     winstation_close_handle,      /* close_handle */
     winstation_destroy            /* destroy */
 };
@@ -132,6 +133,7 @@ static const struct object_ops desktop_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     desktop_close_handle,         /* close_handle */
     desktop_destroy               /* destroy */
 };
-- 
2.49.0


From a9202fae50b9058dc9504c0d39cef01c8eaa1b0d Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 00:38:18 +0200
Subject: [PATCH 03/37] server: Create in-process synchronization objects for
 events.

---
 configure.ac         |   1 +
 server/Makefile.in   |   1 +
 server/event.c       |  22 +++-
 server/inproc_sync.c | 304 +++++++++++++++++++++++++++++++++++++++++++
 server/object.h      |   4 +
 5 files changed, 331 insertions(+), 1 deletion(-)
 create mode 100644 server/inproc_sync.c

diff --git a/configure.ac b/configure.ac
index d4e999fb727..2a5808b65d7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -387,6 +387,7 @@ AC_CHECK_HEADERS(\
 	linux/input.h \
 	linux/ioctl.h \
 	linux/major.h \
+	linux/ntsync.h \
 	linux/param.h \
 	linux/seccomp.h \
 	linux/serial.h \
diff --git a/server/Makefile.in b/server/Makefile.in
index 4e2008a761f..6866b847b46 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -18,6 +18,7 @@ SOURCES = \
 	fsync.c \
 	handle.c \
 	hook.c \
+	inproc_sync.c \
 	mach.c \
 	mailslot.c \
 	main.c \
diff --git a/server/event.c b/server/event.c
index e6c86472c71..a9dc739a257 100644
--- a/server/event.c
+++ b/server/event.c
@@ -58,6 +58,7 @@ struct event
     struct list    kernel_object;   /* list of kernel object pointers */
     int            manual_reset;    /* is it a manual reset event? */
     int            signaled;        /* event has been signaled */
+    struct inproc_sync *inproc_sync;/* in-process synchronization object */
     int            esync_fd;        /* esync file descriptor */
     unsigned int   fsync_idx;
 };
@@ -69,6 +70,7 @@ static int event_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int event_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static int event_signal( struct object *obj, unsigned int access);
 static struct list *event_get_kernel_obj_list( struct object *obj );
+static struct inproc_sync *event_get_inproc_sync( struct object *obj );
 static void event_destroy( struct object *obj );
 
 static const struct object_ops event_ops =
@@ -93,7 +95,7 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    event_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     event_destroy              /* destroy */
 };
@@ -163,6 +165,7 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
             list_init( &event->kernel_object );
             event->manual_reset = manual_reset;
             event->signaled     = initial_state;
+            event->inproc_sync    = NULL;
             event->fsync_idx = 0;
 
             if (do_fsync())
@@ -216,6 +219,7 @@ void set_event( struct event *event )
     event->signaled = 1;
     /* wake up all waiters if manual reset, a single one otherwise */
     wake_up( &event->obj, !event->manual_reset );
+    set_inproc_event( event->inproc_sync );
 }
 
 void reset_event( struct event *event )
@@ -238,6 +242,8 @@ void reset_event( struct event *event )
 
     if (do_esync())
         esync_clear( event->esync_fd );
+
+    reset_inproc_event( event->inproc_sync );
 }
 
 static void event_dump( struct object *obj, int verbose )
@@ -297,6 +303,19 @@ static struct list *event_get_kernel_obj_list( struct object *obj )
     return &event->kernel_object;
 }
 
+static struct inproc_sync *event_get_inproc_sync( struct object *obj )
+{
+    struct event *event = (struct event *)obj;
+
+    if (!event->inproc_sync)
+    {
+        enum inproc_sync_type type = event->manual_reset ? INPROC_SYNC_MANUAL_EVENT : INPROC_SYNC_AUTO_EVENT;
+        event->inproc_sync = create_inproc_event( type, event->signaled );
+    }
+    if (event->inproc_sync) grab_object( event->inproc_sync );
+    return event->inproc_sync;
+}
+
 static void event_destroy( struct object *obj )
 {
     struct event *event = (struct event *)obj;
@@ -304,6 +323,7 @@ static void event_destroy( struct object *obj )
     if (do_esync())
         close( event->esync_fd );
     if (event->fsync_idx) fsync_free_shm_idx( event->fsync_idx );
+    if (event->inproc_sync) release_object( event->inproc_sync );
 }
 
 struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
diff --git a/server/inproc_sync.c b/server/inproc_sync.c
new file mode 100644
index 00000000000..9054d48fca4
--- /dev/null
+++ b/server/inproc_sync.c
@@ -0,0 +1,304 @@
+/*
+ * In-process synchronization primitives
+ *
+ * Copyright (C) 2021-2022 Elizabeth Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "winternl.h"
+
+#include "file.h"
+#include "thread.h"
+
+#ifdef HAVE_LINUX_NTSYNC_H
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <linux/ntsync.h>
+
+struct linux_device
+{
+    struct object obj;      /* object header */
+    struct fd *fd;          /* fd for unix fd */
+};
+
+static struct linux_device *linux_device_object;
+
+static void linux_device_dump( struct object *obj, int verbose );
+static struct fd *linux_device_get_fd( struct object *obj );
+static void linux_device_destroy( struct object *obj );
+static enum server_fd_type inproc_sync_get_fd_type( struct fd *fd );
+
+static const struct object_ops linux_device_ops =
+{
+    sizeof(struct linux_device),        /* size */
+    &no_type,                           /* type */
+    linux_device_dump,                  /* dump */
+    no_add_queue,                       /* add_queue */
+    NULL,                               /* remove_queue */
+    NULL,                               /* signaled */
+    NULL,                               /* get_esync_fd */
+    NULL,                               /* get_fsync_idx */
+    NULL,                               /* satisfied */
+    no_signal,                          /* signal */
+    linux_device_get_fd,                /* get_fd */
+    default_map_access,                 /* map_access */
+    default_get_sd,                     /* get_sd */
+    default_set_sd,                     /* set_sd */
+    no_get_full_name,                   /* get_full_name */
+    no_lookup_name,                     /* lookup_name */
+    no_link_name,                       /* link_name */
+    NULL,                               /* unlink_name */
+    no_open_file,                       /* open_file */
+    no_kernel_obj_list,                 /* get_kernel_obj_list */
+    no_get_inproc_sync,                 /* get_inproc_sync */
+    no_close_handle,                    /* close_handle */
+    linux_device_destroy                /* destroy */
+};
+
+static const struct fd_ops inproc_sync_fd_ops =
+{
+    default_fd_get_poll_events,     /* get_poll_events */
+    default_poll_event,             /* poll_event */
+    inproc_sync_get_fd_type,        /* get_fd_type */
+    no_fd_read,                     /* read */
+    no_fd_write,                    /* write */
+    no_fd_flush,                    /* flush */
+    no_fd_get_file_info,            /* get_file_info */
+    no_fd_get_volume_info,          /* get_volume_info */
+    no_fd_ioctl,                    /* ioctl */
+    default_fd_cancel_async,        /* cancel_async */
+    no_fd_queue_async,              /* queue_async */
+    default_fd_reselect_async       /* reselect_async */
+};
+
+static void linux_device_dump( struct object *obj, int verbose )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    assert( obj->ops == &linux_device_ops );
+    fprintf( stderr, "In-process synchronization device fd=%p\n", device->fd );
+}
+
+static struct fd *linux_device_get_fd( struct object *obj )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    return (struct fd *)grab_object( device->fd );
+}
+
+static void linux_device_destroy( struct object *obj )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    assert( obj->ops == &linux_device_ops );
+    if (device->fd) release_object( device->fd );
+    linux_device_object = NULL;
+}
+
+static enum server_fd_type inproc_sync_get_fd_type( struct fd *fd )
+{
+    return FD_TYPE_FILE;
+}
+
+static struct linux_device *get_linux_device(void)
+{
+    struct linux_device *device;
+    int unix_fd;
+
+    if (linux_device_object)
+        return (struct linux_device *)grab_object( linux_device_object );
+
+    unix_fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
+    if (unix_fd == -1)
+    {
+        file_set_error();
+        return NULL;
+    }
+
+    if (!(device = alloc_object( &linux_device_ops )))
+    {
+        close( unix_fd );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
+    }
+
+    if (!(device->fd = create_anonymous_fd( &inproc_sync_fd_ops, unix_fd, &device->obj, 0 )))
+    {
+        release_object( device );
+        return NULL;
+    }
+
+    linux_device_object = device;
+    return device;
+}
+
+struct inproc_sync
+{
+    struct object obj;
+    enum inproc_sync_type type;
+    struct fd *fd;
+};
+
+static void linux_obj_dump( struct object *obj, int verbose );
+static void linux_obj_destroy( struct object *obj );
+
+static const struct object_ops inproc_sync_ops =
+{
+    sizeof(struct inproc_sync), /* size */
+    &no_type,                   /* type */
+    linux_obj_dump,             /* dump */
+    no_add_queue,               /* add_queue */
+    NULL,                       /* remove_queue */
+    NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
+    NULL,                       /* satisfied */
+    no_signal,                  /* signal */
+    no_get_fd,                  /* get_fd */
+    default_map_access,         /* map_access */
+    default_get_sd,             /* get_sd */
+    default_set_sd,             /* set_sd */
+    no_get_full_name,           /* get_full_name */
+    no_lookup_name,             /* lookup_name */
+    no_link_name,               /* link_name */
+    NULL,                       /* unlink_name */
+    no_open_file,               /* open_file */
+    no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
+    no_close_handle,            /* close_handle */
+    linux_obj_destroy           /* destroy */
+};
+
+static void linux_obj_dump( struct object *obj, int verbose )
+{
+    struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
+    assert( obj->ops == &inproc_sync_ops );
+    fprintf( stderr, "In-process synchronization object type=%u fd=%p\n", inproc_sync->type, inproc_sync->fd );
+}
+
+static void linux_obj_destroy( struct object *obj )
+{
+    struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
+    assert( obj->ops == &inproc_sync_ops );
+    if (inproc_sync->fd) release_object( inproc_sync->fd );
+}
+
+static struct inproc_sync *create_inproc_sync( enum inproc_sync_type type, int unix_fd )
+{
+    struct inproc_sync *inproc_sync;
+
+    if (!(inproc_sync = alloc_object( &inproc_sync_ops )))
+    {
+        close( unix_fd );
+        return NULL;
+    }
+
+    inproc_sync->type = type;
+
+    if (!(inproc_sync->fd = create_anonymous_fd( &inproc_sync_fd_ops, unix_fd, &inproc_sync->obj, 0 )))
+    {
+        release_object( inproc_sync );
+        return NULL;
+    }
+
+    return inproc_sync;
+}
+
+struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled )
+{
+    struct ntsync_event_args args;
+    struct linux_device *device;
+    int event;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.signaled = signaled;
+    switch (type)
+    {
+        case INPROC_SYNC_AUTO_EVENT:
+        case INPROC_SYNC_AUTO_SERVER:
+            args.manual = 0;
+            break;
+
+        case INPROC_SYNC_MANUAL_EVENT:
+        case INPROC_SYNC_MANUAL_SERVER:
+        case INPROC_SYNC_QUEUE:
+            args.manual = 1;
+            break;
+
+        case INPROC_SYNC_MUTEX:
+        case INPROC_SYNC_SEMAPHORE:
+            assert(0);
+            break;
+    }
+    if ((event = ioctl( get_unix_fd( device->fd ), NTSYNC_IOC_CREATE_EVENT, &args )) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+    release_object( device );
+
+    return create_inproc_sync( type, event );
+}
+
+void set_inproc_event( struct inproc_sync *inproc_sync )
+{
+    __u32 count;
+
+    if (!inproc_sync) return;
+
+    if (debug_level) fprintf( stderr, "set_inproc_event %p\n", inproc_sync->fd );
+
+    ioctl( get_unix_fd( inproc_sync->fd ), NTSYNC_IOC_EVENT_SET, &count );
+}
+
+void reset_inproc_event( struct inproc_sync *inproc_sync )
+{
+    __u32 count;
+
+    if (!inproc_sync) return;
+
+    if (debug_level) fprintf( stderr, "set_inproc_event %p\n", inproc_sync->fd );
+
+    ioctl( get_unix_fd( inproc_sync->fd ), NTSYNC_IOC_EVENT_RESET, &count );
+}
+
+#else
+
+struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
+void set_inproc_event( struct inproc_sync *inproc_sync )
+{
+}
+
+void reset_inproc_event( struct inproc_sync *obj )
+{
+}
+
+#endif
diff --git a/server/object.h b/server/object.h
index 403dfa3b141..346ee6abc98 100644
--- a/server/object.h
+++ b/server/object.h
@@ -239,6 +239,10 @@ extern void abandon_mutexes( struct thread *thread );
 
 /* in-process synchronization functions */
 
+extern struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled );
+extern void set_inproc_event( struct inproc_sync *obj );
+extern void reset_inproc_event( struct inproc_sync *obj );
+
 extern struct inproc_sync *no_get_inproc_sync( struct object *obj );
 
 /* serial functions */
-- 
2.49.0


From 490d2fabaa25190af99f3faf917c1d4458bb4214 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 11 Mar 2021 16:45:30 -0600
Subject: [PATCH 04/37] server: Create in-process synchronization objects for
 semaphores.

---
 server/inproc_sync.c | 46 +++++++++++++++++++++++++++++++++++++++-----
 server/object.h      |  1 +
 server/semaphore.c   | 25 ++++++++++++++++++++++--
 3 files changed, 65 insertions(+), 7 deletions(-)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 9054d48fca4..8d01deffa1a 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -162,8 +162,9 @@ struct inproc_sync
 
 static void linux_obj_dump( struct object *obj, int verbose );
 static void linux_obj_destroy( struct object *obj );
+static struct fd *linux_obj_get_fd( struct object *obj );
 
-static const struct object_ops inproc_sync_ops =
+static const struct object_ops linux_obj_ops =
 {
     sizeof(struct inproc_sync), /* size */
     &no_type,                   /* type */
@@ -175,7 +176,7 @@ static const struct object_ops inproc_sync_ops =
     NULL,                       /* get_fsync_idx */
     NULL,                       /* satisfied */
     no_signal,                  /* signal */
-    no_get_fd,                  /* get_fd */
+    linux_obj_get_fd,           /* get_fd */
     default_map_access,         /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
@@ -193,22 +194,29 @@ static const struct object_ops inproc_sync_ops =
 static void linux_obj_dump( struct object *obj, int verbose )
 {
     struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
-    assert( obj->ops == &inproc_sync_ops );
+    assert( obj->ops == &linux_obj_ops );
     fprintf( stderr, "In-process synchronization object type=%u fd=%p\n", inproc_sync->type, inproc_sync->fd );
 }
 
 static void linux_obj_destroy( struct object *obj )
 {
     struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
-    assert( obj->ops == &inproc_sync_ops );
+    assert( obj->ops == &linux_obj_ops );
     if (inproc_sync->fd) release_object( inproc_sync->fd );
 }
 
+static struct fd *linux_obj_get_fd( struct object *obj )
+{
+    struct inproc_sync *inproc_sync = (struct inproc_sync *)obj;
+    assert( obj->ops == &linux_obj_ops );
+    return (struct fd *)grab_object( inproc_sync->fd );
+}
+
 static struct inproc_sync *create_inproc_sync( enum inproc_sync_type type, int unix_fd )
 {
     struct inproc_sync *inproc_sync;
 
-    if (!(inproc_sync = alloc_object( &inproc_sync_ops )))
+    if (!(inproc_sync = alloc_object( &linux_obj_ops )))
     {
         close( unix_fd );
         return NULL;
@@ -263,6 +271,28 @@ struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signale
     return create_inproc_sync( type, event );
 }
 
+struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int max )
+{
+    struct ntsync_sem_args args;
+    struct linux_device *device;
+    int semaphore;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.count = count;
+    args.max = max;
+    if ((semaphore = ioctl( get_unix_fd( device->fd ), NTSYNC_IOC_CREATE_SEM, &args )) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+
+    release_object( device );
+
+    return create_inproc_sync( INPROC_SYNC_SEMAPHORE, semaphore );
+}
+
 void set_inproc_event( struct inproc_sync *inproc_sync )
 {
     __u32 count;
@@ -293,6 +323,12 @@ struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signale
     return NULL;
 }
 
+struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int max )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
 void set_inproc_event( struct inproc_sync *inproc_sync )
 {
 }
diff --git a/server/object.h b/server/object.h
index 346ee6abc98..56e9c7c24db 100644
--- a/server/object.h
+++ b/server/object.h
@@ -240,6 +240,7 @@ extern void abandon_mutexes( struct thread *thread );
 /* in-process synchronization functions */
 
 extern struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled );
+extern struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int max );
 extern void set_inproc_event( struct inproc_sync *obj );
 extern void reset_inproc_event( struct inproc_sync *obj );
 
diff --git a/server/semaphore.c b/server/semaphore.c
index 567a922c0ac..778823394a6 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -55,12 +55,15 @@ struct semaphore
     struct object  obj;    /* object header */
     unsigned int   count;  /* current count */
     unsigned int   max;    /* maximum possible count */
+    struct inproc_sync *inproc_sync; /* fast synchronization object */
 };
 
 static void semaphore_dump( struct object *obj, int verbose );
 static int semaphore_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void semaphore_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static int semaphore_signal( struct object *obj, unsigned int access );
+static struct inproc_sync *semaphore_get_inproc_sync( struct object *obj );
+static void semaphore_destroy( struct object *obj );
 
 static const struct object_ops semaphore_ops =
 {
@@ -84,9 +87,9 @@ static const struct object_ops semaphore_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_inproc_sync,            /* get_inproc_sync */
+    semaphore_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,               /* close_handle */
-    no_destroy                     /* destroy */
+    semaphore_destroy              /* destroy */
 };
 
 
@@ -108,6 +111,7 @@ static struct semaphore *create_semaphore( struct object *root, const struct uni
             /* initialize it if it didn't already exist */
             sem->count = initial;
             sem->max   = max;
+            sem->inproc_sync = NULL;
         }
     }
     return sem;
@@ -170,6 +174,23 @@ static int semaphore_signal( struct object *obj, unsigned int access )
     return release_semaphore( sem, 1, NULL );
 }
 
+static struct inproc_sync *semaphore_get_inproc_sync( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (!semaphore->inproc_sync)
+        semaphore->inproc_sync = create_inproc_semaphore( semaphore->count, semaphore->max );
+    if (semaphore->inproc_sync) grab_object( semaphore->inproc_sync );
+    return semaphore->inproc_sync;
+}
+
+static void semaphore_destroy( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (semaphore->inproc_sync) release_object( semaphore->inproc_sync );
+}
+
 /* create a semaphore */
 DECL_HANDLER(create_semaphore)
 {
-- 
2.49.0


From a9adb7749752be8d4d84668f3016e5ac3ff179ef Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 11 Mar 2021 16:52:55 -0600
Subject: [PATCH 05/37] server: Create in-process synchronization objects for
 mutexes.

---
 server/inproc_sync.c | 37 +++++++++++++++++++++++++++++++++++++
 server/mutex.c       | 40 +++++++++++++++++++++++++++++++++++-----
 server/object.h      |  2 ++
 3 files changed, 74 insertions(+), 5 deletions(-)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 8d01deffa1a..11c0a87d13f 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -293,6 +293,28 @@ struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int ma
     return create_inproc_sync( INPROC_SYNC_SEMAPHORE, semaphore );
 }
 
+struct inproc_sync *create_inproc_mutex( thread_id_t owner, unsigned int count )
+{
+    struct ntsync_mutex_args args;
+    struct linux_device *device;
+    int mutex;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.owner = owner;
+    args.count = count;
+    if ((mutex = ioctl( get_unix_fd( device->fd ), NTSYNC_IOC_CREATE_MUTEX, &args )) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+
+    release_object( device );
+
+    return create_inproc_sync( INPROC_SYNC_MUTEX, mutex );
+}
+
 void set_inproc_event( struct inproc_sync *inproc_sync )
 {
     __u32 count;
@@ -315,6 +337,11 @@ void reset_inproc_event( struct inproc_sync *inproc_sync )
     ioctl( get_unix_fd( inproc_sync->fd ), NTSYNC_IOC_EVENT_RESET, &count );
 }
 
+void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync )
+{
+    ioctl( get_unix_fd( inproc_sync->fd ), NTSYNC_IOC_MUTEX_KILL, &tid );
+}
+
 #else
 
 struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled )
@@ -329,6 +356,12 @@ struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int ma
     return NULL;
 }
 
+struct inproc_sync *create_inproc_mutex( thread_id_t owner, unsigned int count )
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+}
+
 void set_inproc_event( struct inproc_sync *inproc_sync )
 {
 }
@@ -337,4 +370,8 @@ void reset_inproc_event( struct inproc_sync *obj )
 {
 }
 
+void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync )
+{
+}
+
 #endif
diff --git a/server/mutex.c b/server/mutex.c
index 58ac83bd3f7..d97f54b8e82 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -38,6 +38,8 @@
 
 static const WCHAR mutex_name[] = {'M','u','t','a','n','t'};
 
+static struct list inproc_mutexes = LIST_INIT(inproc_mutexes);
+
 struct type_descr mutex_type =
 {
     { mutex_name, sizeof(mutex_name) },   /* name */
@@ -57,6 +59,8 @@ struct mutex
     unsigned int   count;           /* recursion count */
     int            abandoned;       /* has it been abandoned? */
     struct list    entry;           /* entry in owner thread mutex list */
+    struct list    inproc_mutexes_entry; /* entry in inproc_mutexes list */
+    struct inproc_sync *inproc_sync;/* in-process synchronization object */
 };
 
 static void mutex_dump( struct object *obj, int verbose );
@@ -64,6 +68,7 @@ static int mutex_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_destroy( struct object *obj );
 static int mutex_signal( struct object *obj, unsigned int access );
+static struct inproc_sync *mutex_get_inproc_sync( struct object *obj );
 
 static const struct object_ops mutex_ops =
 {
@@ -87,7 +92,7 @@ static const struct object_ops mutex_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    mutex_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
@@ -130,6 +135,7 @@ static struct mutex *create_mutex( struct object *root, const struct unicode_str
             mutex->owner = NULL;
             mutex->abandoned = 0;
             if (owned) do_grab( mutex, current );
+            mutex->inproc_sync = NULL;
         }
     }
     return mutex;
@@ -137,16 +143,20 @@ static struct mutex *create_mutex( struct object *root, const struct unicode_str
 
 void abandon_mutexes( struct thread *thread )
 {
+    struct mutex *mutex;
     struct list *ptr;
 
     while ((ptr = list_head( &thread->mutex_list )) != NULL)
     {
-        struct mutex *mutex = LIST_ENTRY( ptr, struct mutex, entry );
+        mutex = LIST_ENTRY( ptr, struct mutex, entry );
         assert( mutex->owner == thread );
         mutex->count = 0;
         mutex->abandoned = 1;
         do_release( mutex );
     }
+
+    LIST_FOR_EACH_ENTRY(mutex, &inproc_mutexes, struct mutex, inproc_mutexes_entry)
+        abandon_inproc_mutex( thread->id, mutex->inproc_sync );
 }
 
 static void mutex_dump( struct object *obj, int verbose )
@@ -192,14 +202,34 @@ static int mutex_signal( struct object *obj, unsigned int access )
     return 1;
 }
 
+static struct inproc_sync *mutex_get_inproc_sync( struct object *obj )
+{
+    struct mutex *mutex = (struct mutex *)obj;
+
+    if (!mutex->inproc_sync)
+    {
+        mutex->inproc_sync = create_inproc_mutex( mutex->owner ? mutex->owner->id : 0, mutex->count );
+        if (mutex->inproc_sync) list_add_tail( &inproc_mutexes, &mutex->inproc_mutexes_entry );
+    }
+    if (mutex->inproc_sync) grab_object( mutex->inproc_sync );
+    return mutex->inproc_sync;
+}
+
 static void mutex_destroy( struct object *obj )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
 
-    if (!mutex->count) return;
-    mutex->count = 0;
-    do_release( mutex );
+    if (mutex->count)
+    {
+        mutex->count = 0;
+        do_release( mutex );
+    }
+    if (mutex->inproc_sync)
+    {
+        release_object( mutex->inproc_sync );
+        list_remove( &mutex->inproc_mutexes_entry );
+    }
 }
 
 /* create a mutex */
diff --git a/server/object.h b/server/object.h
index 56e9c7c24db..2567f3a07e2 100644
--- a/server/object.h
+++ b/server/object.h
@@ -240,9 +240,11 @@ extern void abandon_mutexes( struct thread *thread );
 /* in-process synchronization functions */
 
 extern struct inproc_sync *create_inproc_event( enum inproc_sync_type type, int signaled );
+extern struct inproc_sync *create_inproc_mutex( thread_id_t owner, unsigned int count );
 extern struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned int max );
 extern void set_inproc_event( struct inproc_sync *obj );
 extern void reset_inproc_event( struct inproc_sync *obj );
+extern void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync );
 
 extern struct inproc_sync *no_get_inproc_sync( struct object *obj );
 
-- 
2.49.0


From 6dbd510d8e1d75943e673b0ff6a3297318e7e379 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 12 Mar 2021 04:32:58 +0200
Subject: [PATCH 06/37] server: Create in-process synchronization objects for
 completion ports.

---
 server/completion.c | 24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/server/completion.c b/server/completion.c
index e2fd3b39924..ce9fd598abf 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -79,6 +79,7 @@ struct completion
     struct list    wait_queue;
     unsigned int   depth;
     int            closed;
+    struct inproc_sync *inproc_sync;
     int                esync_fd;
     unsigned int       fsync_idx;
 };
@@ -170,6 +171,7 @@ static int completion_signaled( struct object *obj, struct wait_queue_entry *ent
 static int completion_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int completion_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static int completion_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
+static struct inproc_sync *completion_get_inproc_sync( struct object *obj );
 static void completion_destroy( struct object * );
 
 static const struct object_ops completion_ops =
@@ -194,7 +196,7 @@ static const struct object_ops completion_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    completion_get_inproc_sync,/* get_inproc_sync */
     completion_close_handle,   /* close_handle */
     completion_destroy         /* destroy */
 };
@@ -211,6 +213,7 @@ static void completion_destroy( struct object *obj)
     {
         free( tmp );
     }
+    if (completion->inproc_sync) release_object( completion->inproc_sync );
 }
 
 static void completion_dump( struct object *obj, int verbose )
@@ -265,6 +268,7 @@ static int completion_close_handle( struct object *obj, struct process *process,
     }
     completion->closed = 1;
     wake_up( obj, 0 );
+    set_inproc_event( completion->inproc_sync );
     return 1;
 }
 
@@ -298,6 +302,16 @@ static struct completion_wait *create_completion_wait( struct thread *thread )
     return wait;
 }
 
+static struct inproc_sync *completion_get_inproc_sync( struct object *obj )
+{
+    struct completion *completion = (struct completion *)obj;
+
+    if (!completion->inproc_sync)
+        completion->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, !list_empty( &completion->queue ) );
+    if (completion->inproc_sync) grab_object( completion->inproc_sync );
+    return completion->inproc_sync;
+}
+
 static struct completion *create_completion( struct object *root, const struct unicode_str *name,
                                              unsigned int attr, unsigned int concurrent,
                                              const struct security_descriptor *sd )
@@ -312,6 +326,7 @@ static struct completion *create_completion( struct object *root, const struct u
             list_init( &completion->wait_queue );
             completion->depth = 0;
             completion->closed = 0;
+            completion->inproc_sync = NULL;
         }
     }
     if (do_esync()) completion->esync_fd = esync_create_fd( 0, 0 );
@@ -346,7 +361,11 @@ void add_completion( struct completion *completion, apc_param_t ckey, apc_param_
         wake_up( &wait->obj, 1 );
         if (list_empty( &completion->queue )) return;
     }
-    if (!list_empty( &completion->queue )) wake_up( &completion->obj, 0 );
+    if (!list_empty( &completion->queue ))
+    {
+        wake_up( &completion->obj, 0 );
+        set_inproc_event( completion->inproc_sync );
+    }
 }
 
 /* create a completion */
@@ -451,6 +470,7 @@ DECL_HANDLER(remove_completion)
         {
             if (do_esync()) esync_clear( completion->esync_fd );
             if (do_fsync()) fsync_clear( &completion->obj );
+            reset_inproc_event( completion->inproc_sync );
         }
     }
 
-- 
2.49.0


From 3e44698b695e3c96f3bf91aa45026a3eea1edb7f Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 16:54:34 -0600
Subject: [PATCH 07/37] server: Create in-process synchronization objects for
 consoles.

---
 server/console.c | 64 ++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 59 insertions(+), 5 deletions(-)

diff --git a/server/console.c b/server/console.c
index 530ee31581f..7bee3435b6d 100644
--- a/server/console.c
+++ b/server/console.c
@@ -63,6 +63,7 @@ struct console
     struct fd                   *fd;            /* for bare console, attached input fd */
     struct async_queue           ioctl_q;       /* ioctl queue */
     struct async_queue           read_q;        /* read queue */
+    struct inproc_sync          *inproc_sync;   /* in-process synchronization object */
 };
 
 static void console_dump( struct object *obj, int verbose );
@@ -74,6 +75,7 @@ static struct object *console_lookup_name( struct object *obj, struct unicode_st
 static struct object *console_open_file( struct object *obj, unsigned int access,
                                          unsigned int sharing, unsigned int options );
 static int console_add_queue( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *console_get_inproc_sync( struct object *obj );
 
 static const struct object_ops console_ops =
 {
@@ -97,7 +99,7 @@ static const struct object_ops console_ops =
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    console_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -230,6 +232,7 @@ static int screen_buffer_add_queue( struct object *obj, struct wait_queue_entry
 static struct fd *screen_buffer_get_fd( struct object *obj );
 static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options );
+static struct inproc_sync *screen_buffer_get_inproc_sync( struct object *obj );
 
 static const struct object_ops screen_buffer_ops =
 {
@@ -253,7 +256,7 @@ static const struct object_ops screen_buffer_ops =
     NULL,                             /* unlink_name */
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    screen_buffer_get_inproc_sync,    /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
@@ -321,6 +324,7 @@ static struct object *console_input_open_file( struct object *obj, unsigned int
                                                unsigned int sharing, unsigned int options );
 static int console_input_add_queue( struct object *obj, struct wait_queue_entry *entry );
 static struct fd *console_input_get_fd( struct object *obj );
+static struct inproc_sync *console_input_get_inproc_sync( struct object *obj );
 static void console_input_destroy( struct object *obj );
 
 static const struct object_ops console_input_ops =
@@ -345,7 +349,7 @@ static const struct object_ops console_input_ops =
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    console_input_get_inproc_sync,    /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -381,6 +385,7 @@ static int console_output_add_queue( struct object *obj, struct wait_queue_entry
 static struct fd *console_output_get_fd( struct object *obj );
 static struct object *console_output_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static struct inproc_sync *console_output_get_inproc_sync( struct object *obj );
 static void console_output_destroy( struct object *obj );
 
 static const struct object_ops console_output_ops =
@@ -405,7 +410,7 @@ static const struct object_ops console_output_ops =
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    console_output_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -566,6 +571,7 @@ static struct object *create_console(void)
     console->server        = NULL;
     console->fd            = NULL;
     console->last_id       = 0;
+    console->inproc_sync     = NULL;
     init_async_queue( &console->ioctl_q );
     init_async_queue( &console->read_q );
 
@@ -795,6 +801,8 @@ static void console_destroy( struct object *obj )
     free_async_queue( &console->read_q );
     if (console->fd)
         release_object( console->fd );
+
+    if (console->inproc_sync) release_object( console->inproc_sync );
 }
 
 static struct object *create_console_connection( struct console *console )
@@ -848,6 +856,16 @@ static struct object *console_open_file( struct object *obj, unsigned int access
     return grab_object( obj );
 }
 
+static struct inproc_sync *console_get_inproc_sync( struct object *obj )
+{
+    struct console *console = (struct console *)obj;
+
+    if (!console->inproc_sync)
+        console->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, console->signaled );
+    if (console->inproc_sync) grab_object( console->inproc_sync );
+    return console->inproc_sync;
+}
+
 static void screen_buffer_dump( struct object *obj, int verbose )
 {
     struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
@@ -897,6 +915,17 @@ static struct fd *screen_buffer_get_fd( struct object *obj )
     return NULL;
 }
 
+static struct inproc_sync *screen_buffer_get_inproc_sync( struct object *obj )
+{
+    struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
+    if (!screen_buffer->input)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_inproc_sync( &screen_buffer->input->obj );
+}
+
 static void console_server_dump( struct object *obj, int verbose )
 {
     assert( obj->ops == &console_server_ops );
@@ -1469,6 +1498,16 @@ static struct object *console_input_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct inproc_sync *console_input_get_inproc_sync( struct object *obj )
+{
+    if (!current->process->console)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_inproc_sync( &current->process->console->obj );
+}
+
 static void console_input_destroy( struct object *obj )
 {
     struct console_input *console_input = (struct console_input *)obj;
@@ -1541,6 +1580,16 @@ static struct object *console_output_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct inproc_sync *console_output_get_inproc_sync( struct object *obj )
+{
+    if (!current->process->console || !current->process->console->active)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_inproc_sync( &current->process->console->obj );
+}
+
 static void console_output_destroy( struct object *obj )
 {
     struct console_output *console_output = (struct console_output *)obj;
@@ -1598,11 +1647,16 @@ DECL_HANDLER(get_next_console_request)
 
     if (!server->console->renderer) server->console->renderer = current;
 
-    if (!req->signal) server->console->signaled = 0;
+    if (!req->signal)
+    {
+        server->console->signaled = 0;
+        reset_inproc_event( server->console->inproc_sync );
+    }
     else if (!server->console->signaled)
     {
         server->console->signaled = 1;
         wake_up( &server->console->obj, 0 );
+        set_inproc_event( server->console->inproc_sync );
     }
 
     if (req->read)
-- 
2.49.0


From 1611be0f6d70b84828b54b1ea56b233a2dee0248 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:00:51 +0200
Subject: [PATCH 08/37] server: Create in-process synchronization objects for
 console servers.

---
 server/console.c | 24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/server/console.c b/server/console.c
index 7bee3435b6d..e173ad81206 100644
--- a/server/console.c
+++ b/server/console.c
@@ -146,6 +146,7 @@ struct console_server
     unsigned int          once_input : 1; /* flag if input thread has already been requested */
     int                   term_fd;     /* UNIX terminal fd */
     struct termios        termios;     /* original termios */
+    struct inproc_sync   *inproc_sync;    /* in-process synchronization object */
     int                   esync_fd;
     unsigned int          fsync_idx;
 };
@@ -160,6 +161,7 @@ static struct object *console_server_lookup_name( struct object *obj, struct uni
                                                 unsigned int attr, struct object *root );
 static struct object *console_server_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static struct inproc_sync *console_server_get_inproc_sync( struct object *obj );
 
 static const struct object_ops console_server_ops =
 {
@@ -183,7 +185,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    console_server_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -611,6 +613,7 @@ static int queue_host_ioctl( struct console_server *server, unsigned int code, u
     }
     list_add_tail( &server->queue, &ioctl->entry );
     wake_up( &server->obj, 0 );
+    set_inproc_event( server->inproc_sync );
     if (async) set_error( STATUS_PENDING );
     return 1;
 }
@@ -647,6 +650,7 @@ static void disconnect_console_server( struct console_server *server )
         server->console->server = NULL;
         server->console = NULL;
         wake_up( &server->obj, 0 );
+        set_inproc_event( server->inproc_sync );
     }
 }
 
@@ -940,6 +944,7 @@ static void console_server_destroy( struct object *obj )
     if (server->fd) release_object( server->fd );
     if (do_esync()) close( server->esync_fd );
     if (server->fsync_idx) fsync_free_shm_idx( server->fsync_idx );
+    if (server->inproc_sync) release_object( server->inproc_sync );
 }
 
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
@@ -1014,6 +1019,17 @@ static struct object *console_server_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct inproc_sync *console_server_get_inproc_sync( struct object *obj )
+{
+    struct console_server *server = (struct console_server *)obj;
+    int signaled = !server->console || !list_empty( &server->queue );
+
+    if (!server->inproc_sync)
+        server->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, signaled );
+    if (server->inproc_sync) grab_object( server->inproc_sync );
+    return server->inproc_sync;
+}
+
 static struct object *create_console_server( void )
 {
     struct console_server *server;
@@ -1025,6 +1041,7 @@ static struct object *create_console_server( void )
     server->term_fd    = -1;
     list_init( &server->queue );
     list_init( &server->read_queue );
+    server->inproc_sync = NULL;
     server->fd = alloc_pseudo_fd( &console_server_fd_ops, &server->obj, FILE_SYNCHRONOUS_IO_NONALERT );
     if (!server->fd)
     {
@@ -1682,6 +1699,8 @@ DECL_HANDLER(get_next_console_request)
             fsync_clear( &server->obj );
         if (do_esync() && list_empty( &server->queue ))
             esync_clear( server->esync_fd );
+        if (list_empty( &server->queue ))
+            reset_inproc_event( server->inproc_sync );
     }
 
     if (ioctl)
@@ -1772,5 +1791,8 @@ DECL_HANDLER(get_next_console_request)
     if (do_esync() && list_empty( &server->queue ))
         esync_clear( server->esync_fd );
 
+    if (list_empty( &server->queue ))
+        reset_inproc_event( server->inproc_sync );
+
     release_object( server );
 }
-- 
2.49.0


From 44f859a643fd7eed23fa0f9b06176f4adc548c92 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:11:03 -0600
Subject: [PATCH 09/37] server: Create in-process synchronization objects for
 debug objects.

---
 server/debugger.c | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/server/debugger.c b/server/debugger.c
index 249c530e9b1..bb36c7aa51a 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -71,6 +71,7 @@ struct debug_obj
     struct object        obj;         /* object header */
     struct list          event_queue; /* pending events queue */
     unsigned int         flags;       /* debug flags */
+    struct inproc_sync  *inproc_sync; /* in-process synchronization object */
 };
 
 
@@ -107,6 +108,7 @@ static const struct object_ops debug_event_ops =
 
 static void debug_obj_dump( struct object *obj, int verbose );
 static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *debug_obj_get_inproc_sync( struct object *obj );
 static void debug_obj_destroy( struct object *obj );
 
 static const struct object_ops debug_obj_ops =
@@ -131,7 +133,7 @@ static const struct object_ops debug_obj_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_inproc_sync,            /* get_inproc_sync */
+    debug_obj_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
@@ -259,6 +261,7 @@ static void link_event( struct debug_obj *debug_obj, struct debug_event *event )
         /* grab reference since debugger could be killed while trying to wake up */
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        set_inproc_event( debug_obj->inproc_sync );
         release_object( debug_obj );
     }
 }
@@ -271,6 +274,7 @@ static void resume_event( struct debug_obj *debug_obj, struct debug_event *event
     {
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        set_inproc_event( debug_obj->inproc_sync );
         release_object( debug_obj );
     }
 }
@@ -336,6 +340,17 @@ static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entr
     return find_event_to_send( debug_obj ) != NULL;
 }
 
+static struct inproc_sync *debug_obj_get_inproc_sync( struct object *obj )
+{
+    struct debug_obj *debug_obj = (struct debug_obj *)obj;
+    int signaled = find_event_to_send( debug_obj ) != NULL;
+
+    if (!debug_obj->inproc_sync)
+        debug_obj->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, signaled );
+    if (debug_obj->inproc_sync) grab_object( debug_obj->inproc_sync );
+    return debug_obj->inproc_sync;
+}
+
 static void debug_obj_destroy( struct object *obj )
 {
     struct list *ptr;
@@ -348,6 +363,8 @@ static void debug_obj_destroy( struct object *obj )
     /* free all pending events */
     while ((ptr = list_head( &debug_obj->event_queue )))
         unlink_event( debug_obj, LIST_ENTRY( ptr, struct debug_event, entry ));
+
+    if (debug_obj->inproc_sync) release_object( debug_obj->inproc_sync );
 }
 
 struct debug_obj *get_debug_obj( struct process *process, obj_handle_t handle, unsigned int access )
@@ -367,6 +384,7 @@ static struct debug_obj *create_debug_obj( struct object *root, const struct uni
         {
             debug_obj->flags = flags;
             list_init( &debug_obj->event_queue );
+            debug_obj->inproc_sync = NULL;
         }
     }
     return debug_obj;
@@ -575,6 +593,9 @@ DECL_HANDLER(wait_debug_event)
         reply->tid = get_thread_id( event->sender );
         alloc_event_handles( event, current->process );
         set_reply_data( &event->data, min( get_reply_max_size(), sizeof(event->data) ));
+
+        if (!find_event_to_send( debug_obj ))
+            reset_inproc_event( debug_obj->inproc_sync );
     }
     else
     {
-- 
2.49.0


From 23e12d4ed3207f0127add5004e45ea73df729352 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Wed, 10 Mar 2021 19:02:42 +0200
Subject: [PATCH 10/37] server: Create in-process synchronization objects for
 device managers.

---
 server/device.c | 31 +++++++++++++++++++++++++++++--
 1 file changed, 29 insertions(+), 2 deletions(-)

diff --git a/server/device.c b/server/device.c
index 78a37ae3bc0..48969b91a1d 100644
--- a/server/device.c
+++ b/server/device.c
@@ -97,12 +97,14 @@ struct device_manager
     struct list            requests;       /* list of pending irps across all devices */
     struct irp_call       *current_call;   /* call currently executed on client side */
     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
+    struct inproc_sync    *inproc_sync;    /* in-process synchronization object */
     int                    esync_fd;       /* esync file descriptor */
     unsigned int           fsync_idx;
 };
 
 static void device_manager_dump( struct object *obj, int verbose );
 static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *device_manager_get_inproc_sync( struct object *obj );
 static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int device_manager_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void device_manager_destroy( struct object *obj );
@@ -129,7 +131,7 @@ static const struct object_ops device_manager_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    device_manager_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -436,7 +438,12 @@ static void add_irp_to_queue( struct device_manager *manager, struct irp_call *i
     irp->thread = thread ? (struct thread *)grab_object( thread ) : NULL;
     if (irp->file) list_add_tail( &irp->file->requests, &irp->dev_entry );
     list_add_tail( &manager->requests, &irp->mgr_entry );
-    if (list_head( &manager->requests ) == &irp->mgr_entry) wake_up( &manager->obj, 0 );  /* first one */
+    if (list_head( &manager->requests ) == &irp->mgr_entry)
+    {
+        /* first one */
+        wake_up( &manager->obj, 0 );
+        set_inproc_event( manager->inproc_sync );
+    }
 }
 
 static struct object *device_open_file( struct object *obj, unsigned int access,
@@ -776,6 +783,9 @@ static void delete_file( struct device_file *file )
         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
     }
 
+    if (list_empty( &file->device->manager->requests ))
+        reset_inproc_event( file->device->manager->inproc_sync );
+
     release_object( file );
 }
 
@@ -807,6 +817,16 @@ static int device_manager_signaled( struct object *obj, struct wait_queue_entry
     return !list_empty( &manager->requests );
 }
 
+static struct inproc_sync *device_manager_get_inproc_sync( struct object *obj )
+{
+    struct device_manager *manager = (struct device_manager *)obj;
+
+    if (!manager->inproc_sync)
+        manager->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, !list_empty( &manager->requests ) );
+    if (manager->inproc_sync) grab_object( manager->inproc_sync );
+    return manager->inproc_sync;
+}
+
 static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type )
 {
     struct device_manager *manager = (struct device_manager *)obj;
@@ -859,6 +879,8 @@ static void device_manager_destroy( struct object *obj )
     if (do_esync())
         close( manager->esync_fd );
     if (manager->fsync_idx) fsync_free_shm_idx( manager->fsync_idx );
+
+    if (manager->inproc_sync) release_object( manager->inproc_sync );
 }
 
 static struct device_manager *create_device_manager(void)
@@ -868,6 +890,7 @@ static struct device_manager *create_device_manager(void)
     if ((manager = alloc_object( &device_manager_ops )))
     {
         manager->current_call = NULL;
+        manager->inproc_sync = NULL;
         list_init( &manager->devices );
         list_init( &manager->requests );
         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
@@ -1064,6 +1087,10 @@ DECL_HANDLER(get_next_device_request)
                 }
                 list_remove( &irp->mgr_entry );
                 list_init( &irp->mgr_entry );
+
+                if (list_empty( &manager->requests ))
+                    reset_inproc_event( manager->inproc_sync );
+
                 /* we already own the object if it's only on manager queue */
                 if (irp->file) grab_object( irp );
                 manager->current_call = irp;
-- 
2.49.0


From 3f77028e8ad14929fc3adf9b6b1ae12508772bb7 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:13:20 -0600
Subject: [PATCH 11/37] server: Create in-process synchronization objects for
 keyed events.

---
 server/event.c | 25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/server/event.c b/server/event.c
index a9dc739a257..ef14582f1e0 100644
--- a/server/event.c
+++ b/server/event.c
@@ -118,10 +118,13 @@ struct type_descr keyed_event_type =
 struct keyed_event
 {
     struct object  obj;             /* object header */
+    struct inproc_sync *inproc_sync;/* in-process synchronization object */
 };
 
 static void keyed_event_dump( struct object *obj, int verbose );
 static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *keyed_event_get_inproc_sync( struct object *obj );
+static void keyed_event_destroy( struct object *obj );
 
 static const struct object_ops keyed_event_ops =
 {
@@ -145,9 +148,9 @@ static const struct object_ops keyed_event_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
-    no_get_inproc_sync,          /* get_inproc_sync */
+    keyed_event_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,             /* close_handle */
-    no_destroy                   /* destroy */
+    keyed_event_destroy          /* destroy */
 };
 
 
@@ -336,6 +339,7 @@ struct keyed_event *create_keyed_event( struct object *root, const struct unicod
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
+            event->inproc_sync = NULL;
         }
     }
     return event;
@@ -379,6 +383,23 @@ static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *en
     return 0;
 }
 
+static struct inproc_sync *keyed_event_get_inproc_sync( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (!event->inproc_sync)
+        event->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, 1 );
+    if (event->inproc_sync) grab_object( event->inproc_sync );
+    return event->inproc_sync;
+}
+
+static void keyed_event_destroy( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (event->inproc_sync) release_object( event->inproc_sync );
+}
+
 /* create an event */
 DECL_HANDLER(create_event)
 {
-- 
2.49.0


From ddc0bc41ea1ea6ea66aa2c323b0e712d028a34aa Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:16:53 +0200
Subject: [PATCH 12/37] server: Create in-process synchronization objects for
 processes.

---
 server/process.c | 16 +++++++++++++++-
 server/process.h |  1 +
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/server/process.c b/server/process.c
index 5072b400a70..6e3a93eccf6 100644
--- a/server/process.c
+++ b/server/process.c
@@ -96,6 +96,7 @@ static unsigned int process_map_access( struct object *obj, unsigned int access
 static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static struct list *process_get_kernel_obj_list( struct object *obj );
+static struct inproc_sync *process_get_inproc_sync( struct object *obj );
 static void process_destroy( struct object *obj );
 static int process_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int process_get_fsync_idx( struct object *obj, enum fsync_type *type );
@@ -124,7 +125,7 @@ static const struct object_ops process_ops =
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_inproc_sync,          /* get_inproc_sync */
+    process_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -698,6 +699,7 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
     process->rawinput_device_count = 0;
     process->rawinput_mouse  = NULL;
     process->rawinput_kbd    = NULL;
+    process->inproc_sync       = NULL;
     memset( &process->image_info, 0, sizeof(process->image_info) );
     process->esync_fd        = -1;
     process->fsync_idx       = 0;
@@ -813,6 +815,7 @@ static void process_destroy( struct object *obj )
         fsync_cleanup_process_shm_indices( process->id );
         fsync_free_shm_idx( process->fsync_idx );
     }
+    if (process->inproc_sync) release_object( process->inproc_sync );
 }
 
 /* dump a process on stdout for debugging purposes */
@@ -860,6 +863,16 @@ static struct list *process_get_kernel_obj_list( struct object *obj )
     return &process->kernel_object;
 }
 
+static struct inproc_sync *process_get_inproc_sync( struct object *obj )
+{
+    struct process *process = (struct process *)obj;
+
+    if (!process->inproc_sync)
+        process->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, !process->running_threads );
+    if (process->inproc_sync) grab_object( process->inproc_sync );
+    return process->inproc_sync;
+}
+
 static struct security_descriptor *process_get_sd( struct object *obj )
 {
     static struct security_descriptor *process_default_sd;
@@ -1024,6 +1037,7 @@ static void process_killed( struct process *process )
     release_job_process( process );
     start_sigkill_timer( process );
     wake_up( &process->obj, 0 );
+    set_inproc_event( process->inproc_sync );
 }
 
 /* add a thread to a process running threads list */
diff --git a/server/process.h b/server/process.h
index d2aadd521e8..25604958768 100644
--- a/server/process.h
+++ b/server/process.h
@@ -86,6 +86,7 @@ struct process
     struct list          rawinput_entry;  /* entry in the rawinput process list */
     struct list          kernel_object;   /* list of kernel object pointers */
     struct pe_image_info image_info;      /* main exe image info */
+    struct inproc_sync  *inproc_sync;     /* in-process synchronization object */
     int                  esync_fd;        /* esync file descriptor (signaled on exit) */
     unsigned int         fsync_idx;
     struct cpu_topology_override cpu_override; /* Overridden CPUs to host CPUs mapping. */
-- 
2.49.0


From 4ab579c5efd96bcbca398d779b08620f29f49430 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:17:35 -0600
Subject: [PATCH 13/37] server: Create in-process synchronization objects for
 jobs.

---
 server/process.c | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/server/process.c b/server/process.c
index 6e3a93eccf6..3b70e73d92a 100644
--- a/server/process.c
+++ b/server/process.c
@@ -202,6 +202,7 @@ struct type_descr job_type =
 
 static void job_dump( struct object *obj, int verbose );
 static int job_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *job_get_inproc_sync( struct object *obj );
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 static void job_destroy( struct object *obj );
 
@@ -219,6 +220,7 @@ struct job
     struct job *parent;
     struct list parent_job_entry;  /* list entry for parent job */
     struct list child_job_list;    /* list of child jobs */
+    struct inproc_sync *inproc_sync; /* in-process synchronization object */
 };
 
 static const struct object_ops job_ops =
@@ -243,7 +245,7 @@ static const struct object_ops job_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_inproc_sync,            /* get_inproc_sync */
+    job_get_inproc_sync,           /* get_inproc_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
@@ -268,6 +270,7 @@ static struct job *create_job_object( struct object *root, const struct unicode_
             job->completion_port = NULL;
             job->completion_key = 0;
             job->parent = NULL;
+            job->inproc_sync = NULL;
         }
     }
     return job;
@@ -424,6 +427,17 @@ static void terminate_job( struct job *job, int exit_code )
     job->terminating = 0;
     job->signaled = 1;
     wake_up( &job->obj, 0 );
+    set_inproc_event( job->inproc_sync );
+}
+
+static struct inproc_sync *job_get_inproc_sync( struct object *obj )
+{
+    struct job *job = (struct job *)obj;
+
+    if (!job->inproc_sync)
+        job->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, job->signaled );
+    if (job->inproc_sync) grab_object( job->inproc_sync );
+    return job->inproc_sync;
 }
 
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
@@ -454,6 +468,8 @@ static void job_destroy( struct object *obj )
         list_remove( &job->parent_job_entry );
         release_object( job->parent );
     }
+
+    if (job->inproc_sync) release_object( job->inproc_sync );
 }
 
 static void job_dump( struct object *obj, int verbose )
-- 
2.49.0


From 03741b19b4531f657febc3929a907543037bf082 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:24:15 +0200
Subject: [PATCH 14/37] server: Create in-process synchronization objects for
 message queues.

---
 server/queue.c | 46 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 43 insertions(+), 3 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 6a28c3daac5..9e006690720 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -146,6 +146,7 @@ struct msg_queue
     timeout_t              last_get_msg;    /* time of last get message call */
     int                    keystate_lock;   /* owns an input keystate lock */
     const queue_shm_t     *shared;          /* queue in session shared memory */
+    struct inproc_sync    *inproc_sync;     /* in-process synchronization object */
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
     unsigned int           fsync_idx;
@@ -169,6 +170,7 @@ static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entr
 static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int msg_queue_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *msg_queue_get_inproc_sync( struct object *obj );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
 static void thread_input_dump( struct object *obj, int verbose );
@@ -197,7 +199,7 @@ static const struct object_ops msg_queue_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    msg_queue_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -338,6 +340,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
         queue->keystate_lock   = 0;
+        queue->inproc_sync     = NULL;
         queue->esync_fd        = -1;
         queue->esync_in_msgwait = 0;
         queue->fsync_idx       = 0;
@@ -764,7 +767,11 @@ static inline void set_queue_bits( struct msg_queue *queue, unsigned int bits )
     }
     SHARED_WRITE_END;
 
-    if (is_signaled( queue )) wake_up( &queue->obj, 0 );
+    if (is_signaled( queue ))
+    {
+        wake_up( &queue->obj, 0 );
+        set_inproc_event( queue->inproc_sync );
+    }
 }
 
 /* clear some queue bits */
@@ -1171,6 +1178,9 @@ static void reply_message( struct msg_queue *queue, lparam_t result,
         if (len && (res->data = memdup( data, len ))) res->data_size = len;
         store_message_result( res, result, error );
     }
+
+    if (!is_signaled( queue ))
+        reset_inproc_event( queue->inproc_sync );
 }
 
 static int match_window( user_handle_t win, user_handle_t msg_win )
@@ -1386,6 +1396,18 @@ static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *en
         shared->changed_mask = 0;
     }
     SHARED_WRITE_END;
+
+    reset_inproc_event( queue->inproc_sync );
+}
+
+static struct inproc_sync *msg_queue_get_inproc_sync( struct object *obj )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+
+    if (!queue->inproc_sync)
+        queue->inproc_sync = create_inproc_event( INPROC_SYNC_QUEUE, is_signaled( queue ) );
+    if (queue->inproc_sync) grab_object( queue->inproc_sync );
+    return queue->inproc_sync;
 }
 
 static void msg_queue_destroy( struct object *obj )
@@ -1433,6 +1455,7 @@ static void msg_queue_destroy( struct object *obj )
     if (queue->shared) free_shared_object( queue->shared );
     if (do_esync()) close( queue->esync_fd );
     if (queue->fsync_idx) fsync_free_shm_idx( queue->fsync_idx );
+    if (queue->inproc_sync) release_object( queue->inproc_sync );
 }
 
 static void msg_queue_poll_event( struct fd *fd, int event )
@@ -1443,6 +1466,7 @@ static void msg_queue_poll_event( struct fd *fd, int event )
     if (event & (POLLERR | POLLHUP)) set_fd_events( fd, -1 );
     else set_fd_events( queue->fd, 0 );
     wake_up( &queue->obj, 0 );
+    set_inproc_event( queue->inproc_sync );
 }
 
 static void thread_input_dump( struct object *obj, int verbose )
@@ -3314,7 +3338,15 @@ DECL_HANDLER(set_queue_mask)
                 }
                 SHARED_WRITE_END;
             }
-            else wake_up( &queue->obj, 0 );
+            else
+            {
+                wake_up( &queue->obj, 0 );
+                set_inproc_event( queue->inproc_sync );
+            }
+        }
+        else
+        {
+            reset_inproc_event( queue->inproc_sync );
         }
 
         if (do_fsync() && !is_signaled( queue ))
@@ -3334,6 +3366,9 @@ DECL_HANDLER(get_queue_status)
     {
         const queue_shm_t *queue_shm = queue->shared;
 
+        if (!is_signaled( queue ))
+            reset_inproc_event( queue->inproc_sync );
+
         if (do_fsync() && !is_signaled( queue ))
             fsync_clear( &queue->obj );
 
@@ -3545,6 +3580,9 @@ DECL_HANDLER(get_message)
     }
     SHARED_WRITE_END;
 
+    if (!is_signaled( queue ))
+        reset_inproc_event( queue->inproc_sync );
+
     /* then check for posted messages */
     if ((filter & QS_POSTMESSAGE) &&
         get_posted_message( queue, get_win, req->get_first, req->get_last, req->flags, reply ))
@@ -3604,6 +3642,8 @@ DECL_HANDLER(get_message)
     }
     SHARED_WRITE_END;
 
+    reset_inproc_event( queue->inproc_sync );
+
     set_error( STATUS_PENDING );  /* FIXME */
 
     if (do_fsync() && !is_signaled( queue ))
-- 
2.49.0


From 6fa7bf7e9695c797e1f0f9831460c64bb9fa2499 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:26:35 +0200
Subject: [PATCH 15/37] server: Create in-process synchronization objects for
 threads.

---
 server/thread.c | 16 +++++++++++++++-
 server/thread.h |  1 +
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/server/thread.c b/server/thread.c
index 8fbfd553cc6..baf74aa6e56 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -190,6 +190,7 @@ static unsigned int thread_get_fsync_idx( struct object *obj, enum fsync_type *t
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static struct list *thread_get_kernel_obj_list( struct object *obj );
+static struct inproc_sync *thread_get_inproc_sync( struct object *obj );
 static void destroy_thread( struct object *obj );
 
 static const struct object_ops thread_ops =
@@ -214,7 +215,7 @@ static const struct object_ops thread_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_inproc_sync,         /* get_inproc_sync */
+    thread_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
@@ -312,6 +313,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->token           = NULL;
     thread->desc            = NULL;
     thread->desc_len        = 0;
+    thread->inproc_sync     = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -477,6 +479,16 @@ static struct list *thread_get_kernel_obj_list( struct object *obj )
     return &thread->kernel_object;
 }
 
+static struct inproc_sync *thread_get_inproc_sync( struct object *obj )
+{
+    struct thread *thread = (struct thread *)obj;
+
+    if (!thread->inproc_sync)
+        thread->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, thread->state == TERMINATED );
+    if (thread->inproc_sync) grab_object( thread->inproc_sync );
+    return thread->inproc_sync;
+}
+
 /* cleanup everything that is no longer needed by a dead thread */
 /* used by destroy_thread and kill_thread */
 static void cleanup_thread( struct thread *thread )
@@ -540,6 +552,7 @@ static void destroy_thread( struct object *obj )
         fsync_free_shm_idx( thread->fsync_idx );
         fsync_free_shm_idx( thread->fsync_apc_idx );
     }
+    if (thread->inproc_sync) release_object( thread->inproc_sync );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -1475,6 +1488,7 @@ void kill_thread( struct thread *thread, int violent_death )
     if (do_esync())
         esync_abandon_mutexes( thread );
     wake_up( &thread->obj, 0 );
+    set_inproc_event( thread->inproc_sync );
     if (violent_death) send_thread_signal( thread, SIGQUIT );
     cleanup_thread( thread );
     remove_process_thread( thread->process, thread );
diff --git a/server/thread.h b/server/thread.h
index 057ad9ec2ae..0dae653dea4 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -97,6 +97,7 @@ struct thread
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
     struct completion_wait *completion_wait; /* completion port wait object the thread is associated with */
+    struct inproc_sync    *inproc_sync;   /* in-process synchronization object */
 };
 
 extern struct thread *current;
-- 
2.49.0


From be8874634b71ce1ecc01b08adf1794fb3f0a276f Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 01:29:38 +0200
Subject: [PATCH 16/37] server: Create in-process synchronization objects for
 timers.

---
 server/timer.c | 22 +++++++++++++++++++++-
 1 file changed, 21 insertions(+), 1 deletion(-)

diff --git a/server/timer.c b/server/timer.c
index ca367a6fb7d..1050ac051b1 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -63,6 +63,7 @@ struct timer
     struct thread       *thread;    /* thread that set the APC function */
     client_ptr_t         callback;  /* callback APC function */
     client_ptr_t         arg;       /* callback argument */
+    struct inproc_sync  *inproc_sync;   /* in-process synchronization object */
     int                  esync_fd;  /* esync file descriptor */
     unsigned int         fsync_idx; /* fsync shm index */
 };
@@ -72,6 +73,7 @@ static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int timer_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static struct inproc_sync *timer_get_inproc_sync( struct object *obj );
 static void timer_destroy( struct object *obj );
 
 static const struct object_ops timer_ops =
@@ -96,7 +98,7 @@ static const struct object_ops timer_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    timer_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
@@ -119,6 +121,7 @@ static struct timer *create_timer( struct object *root, const struct unicode_str
             timer->period   = 0;
             timer->timeout  = NULL;
             timer->thread   = NULL;
+            timer->inproc_sync = NULL;
             timer->esync_fd = -1;
             timer->fsync_idx = 0;
 
@@ -168,6 +171,7 @@ static void timer_callback( void *private )
     /* wake up waiters */
     timer->signaled = 1;
     wake_up( &timer->obj, 0 );
+    set_inproc_event( timer->inproc_sync );
 }
 
 /* cancel a running timer */
@@ -204,6 +208,8 @@ static int set_timer( struct timer *timer, timeout_t expire, unsigned int period
 
         if (do_esync())
             esync_clear( timer->esync_fd );
+
+        reset_inproc_event( timer->inproc_sync );
     }
     timer->when     = (expire <= 0) ? expire - monotonic_time : max( expire, current_time );
     timer->period   = period;
@@ -252,6 +258,19 @@ static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry
     if (!timer->manual) timer->signaled = 0;
 }
 
+static struct inproc_sync *timer_get_inproc_sync( struct object *obj )
+{
+    struct timer *timer = (struct timer *)obj;
+
+    if (!timer->inproc_sync)
+    {
+        enum inproc_sync_type type = timer->manual ? INPROC_SYNC_MANUAL_SERVER : INPROC_SYNC_AUTO_SERVER;
+        timer->inproc_sync = create_inproc_event( type, timer->signaled );
+    }
+    if (timer->inproc_sync) grab_object( timer->inproc_sync );
+    return timer->inproc_sync;
+}
+
 static void timer_destroy( struct object *obj )
 {
     struct timer *timer = (struct timer *)obj;
@@ -261,6 +280,7 @@ static void timer_destroy( struct object *obj )
     if (timer->thread) release_object( timer->thread );
     if (do_esync()) close( timer->esync_fd );
     if (timer->fsync_idx) fsync_free_shm_idx( timer->fsync_idx );
+    if (timer->inproc_sync) release_object( timer->inproc_sync );
 }
 
 /* create a timer */
-- 
2.49.0


From 6fdd58ff48fa34988efe44ace7e9d77a3cff720d Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:40:57 -0600
Subject: [PATCH 17/37] server: Create in-process synchronization objects for
 fd-based objects.

---
 server/change.c     |  2 +-
 server/device.c     |  2 +-
 server/fd.c         | 27 ++++++++++++++++++++++++++-
 server/file.c       |  2 +-
 server/file.h       |  1 +
 server/mailslot.c   |  6 +++---
 server/named_pipe.c |  8 ++++----
 server/serial.c     |  2 +-
 server/sock.c       |  2 +-
 9 files changed, 39 insertions(+), 13 deletions(-)

diff --git a/server/change.c b/server/change.c
index f5129001836..5a9667eefcb 100644
--- a/server/change.c
+++ b/server/change.c
@@ -126,7 +126,7 @@ static const struct object_ops dir_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
-    no_get_inproc_sync,       /* get_inproc_sync */
+    default_fd_get_inproc_sync, /* get_inproc_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --git a/server/device.c b/server/device.c
index 48969b91a1d..8c8e9f5e0ad 100644
--- a/server/device.c
+++ b/server/device.c
@@ -246,7 +246,7 @@ static const struct object_ops device_file_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
-    no_get_inproc_sync,               /* get_inproc_sync */
+    default_fd_get_inproc_sync,       /* get_inproc_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
diff --git a/server/fd.c b/server/fd.c
index 5d99eedd340..8e820606a25 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -156,6 +156,7 @@ struct fd
     struct completion   *completion;  /* completion object attached to this fd */
     apc_param_t          comp_key;    /* completion key to set in completion events */
     unsigned int         comp_flags;  /* completion flags */
+    struct inproc_sync  *inproc_sync; /* in-process synchronization object */
     int                  esync_fd;    /* esync file descriptor */
     unsigned int         fsync_idx;   /* fsync shm index */
 };
@@ -1592,6 +1593,7 @@ static void fd_destroy( struct object *obj )
     if (do_esync())
         close( fd->esync_fd );
     if (fd->fsync_idx) fsync_free_shm_idx( fd->fsync_idx );
+    if (fd->inproc_sync) release_object( fd->inproc_sync );
 }
 
 /* check if the desired access is possible without violating */
@@ -1710,6 +1712,7 @@ static struct fd *alloc_fd_object(void)
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->inproc_sync = NULL;
     fd->esync_fd   = -1;
     fd->fsync_idx  = 0;
     init_async_queue( &fd->read_q );
@@ -1758,6 +1761,7 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->inproc_sync = NULL;
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
     fd->esync_fd   = -1;
     fd->fsync_idx  = 0;
@@ -2216,7 +2220,15 @@ void set_fd_signaled( struct fd *fd, int signaled )
 {
     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
     fd->signaled = signaled;
-    if (signaled) wake_up( fd->user, 0 );
+    if (signaled)
+    {
+        wake_up( fd->user, 0 );
+        set_inproc_event( fd->inproc_sync );
+    }
+    else
+    {
+        reset_inproc_event( fd->inproc_sync );
+    }
 
     if (do_fsync() && !signaled)
         fsync_clear( fd->user );
@@ -2266,6 +2278,19 @@ unsigned int default_fd_get_fsync_idx( struct object *obj, enum fsync_type *type
     return ret;
 }
 
+struct inproc_sync *default_fd_get_inproc_sync( struct object *obj )
+{
+    struct fd *fd = get_obj_fd( obj );
+    struct inproc_sync *ret;
+
+    if (!fd->inproc_sync)
+        fd->inproc_sync = create_inproc_event( INPROC_SYNC_MANUAL_SERVER, fd->signaled );
+    ret = fd->inproc_sync;
+    release_object( fd );
+    if (ret) grab_object( ret );
+    return ret;
+}
+
 int default_fd_get_poll_events( struct fd *fd )
 {
     int events = 0;
diff --git a/server/file.c b/server/file.c
index 40ff667c98e..4af412d93c2 100644
--- a/server/file.c
+++ b/server/file.c
@@ -137,7 +137,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --git a/server/file.h b/server/file.h
index e7c5a32bbb5..7fb1301970a 100644
--- a/server/file.h
+++ b/server/file.h
@@ -111,6 +111,7 @@ extern char *dup_fd_name( struct fd *root, const char *name ) __WINE_DEALLOC(fre
 extern void get_nt_name( struct fd *fd, struct unicode_str *name );
 
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
+extern struct inproc_sync *default_fd_get_inproc_sync( struct object *obj );
 extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
 extern unsigned int default_fd_get_fsync_idx( struct object *obj, enum fsync_type *type );
 extern int default_fd_get_poll_events( struct fd *fd );
diff --git a/server/mailslot.c b/server/mailslot.c
index f89778b924e..fef0ce25b4c 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -95,7 +95,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_inproc_sync,        /* get_inproc_sync */
+    default_fd_get_inproc_sync,/* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -159,7 +159,7 @@ static const struct object_ops mail_writer_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
-    no_get_inproc_sync,         /* get_inproc_sync */
+    default_fd_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     mail_writer_destroy         /* destroy */
 };
@@ -260,7 +260,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
-    no_get_inproc_sync,                     /* get_inproc_sync */
+    default_fd_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --git a/server/named_pipe.c b/server/named_pipe.c
index ad0c9f549a6..fbcd75321bc 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -187,7 +187,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -234,7 +234,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -318,7 +318,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
-    no_get_inproc_sync,                      /* get_inproc_sync */
+    default_fd_get_inproc_sync,              /* get_inproc_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
@@ -372,7 +372,7 @@ static const struct object_ops named_pipe_dir_ops =
     NULL,                                    /* unlink_name */
     named_pipe_dir_open_file,                /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
-    no_get_inproc_sync,                      /* get_inproc_sync */
+    default_fd_get_inproc_sync,              /* get_inproc_sync */
     named_pipe_dir_close_handle,             /* close_handle */
     named_pipe_dir_destroy                   /* destroy */
 };
diff --git a/server/serial.c b/server/serial.c
index 93619ebccde..c1bdfbbe2b5 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -105,7 +105,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --git a/server/sock.c b/server/sock.c
index 0e0bfd70793..51dd51bb353 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -485,7 +485,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_inproc_sync,           /* get_inproc_sync */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
-- 
2.49.0


From f1ad604bb17ba59e257d06b3f93c6f3984a485ed Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:46:06 -0600
Subject: [PATCH 18/37] server: Add a request to retrieve the in-process
 synchronization device.

---
 server/inproc_sync.c | 17 +++++++++++++++++
 server/protocol.def  |  6 ++++++
 2 files changed, 23 insertions(+)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 11c0a87d13f..feaa2ad8442 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -29,6 +29,8 @@
 #include "winternl.h"
 
 #include "file.h"
+#include "handle.h"
+#include "request.h"
 #include "thread.h"
 
 #ifdef HAVE_LINUX_NTSYNC_H
@@ -375,3 +377,18 @@ void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync )
 }
 
 #endif
+
+DECL_HANDLER(get_linux_sync_device)
+{
+#ifdef HAVE_LINUX_NTSYNC_H
+    struct linux_device *device;
+
+    if ((device = get_linux_device()))
+    {
+        reply->handle = alloc_handle_no_access_check( current->process, device, 0, 0 );
+        release_object( device );
+    }
+#else
+    set_error( STATUS_NOT_IMPLEMENTED );
+#endif
+}
diff --git a/server/protocol.def b/server/protocol.def
index e240c4212db..8d7d5eba816 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4214,6 +4214,12 @@ enum inproc_sync_type
     INPROC_SYNC_QUEUE,
 };
 
+/* Obtain a handle to the ntsync device object */
+@REQ(get_linux_sync_device)
+@REPLY
+    obj_handle_t handle;          /* handle to the device */
+@END
+
 /* Create a new futex-based synchronization object */
 @REQ(create_fsync)
     unsigned int access;        /* wanted access rights */
-- 
2.49.0


From 9db4c25e8ad3022133ab3d824b99a58a96ddde20 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 8 Mar 2021 17:55:00 -0600
Subject: [PATCH 19/37] server: Add a request to retrieve the in-process
 synchronization object from a handle.

---
 server/inproc_sync.c | 23 +++++++++++++++++++++++
 server/protocol.def  | 10 ++++++++++
 2 files changed, 33 insertions(+)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index feaa2ad8442..6cb02b16832 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -392,3 +392,26 @@ DECL_HANDLER(get_linux_sync_device)
     set_error( STATUS_NOT_IMPLEMENTED );
 #endif
 }
+
+DECL_HANDLER(get_linux_sync_obj)
+{
+#ifdef HAVE_LINUX_NTSYNC_H
+    struct object *obj;
+
+    if ((obj = get_handle_obj( current->process, req->handle, 0, NULL )))
+    {
+        struct inproc_sync *inproc_sync;
+
+        if ((inproc_sync = obj->ops->get_inproc_sync( obj )))
+        {
+            reply->handle = alloc_handle_no_access_check( current->process, inproc_sync, 0, 0 );
+            reply->type = inproc_sync->type;
+            reply->access = get_handle_access( current->process, req->handle );
+            release_object( inproc_sync );
+        }
+        release_object( obj );
+    }
+#else
+    set_error( STATUS_NOT_IMPLEMENTED );
+#endif
+}
diff --git a/server/protocol.def b/server/protocol.def
index 8d7d5eba816..d601aba464b 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4267,3 +4267,13 @@ enum inproc_sync_type
     unsigned int shm_idx;
 @REPLY
 @END
+
+
+/* Get the in-process synchronization object associated with the given handle */
+@REQ(get_linux_sync_obj)
+    obj_handle_t handle;          /* handle to the object */
+@REPLY
+    obj_handle_t handle;          /* handle to the fast synchronization object */
+    int          type;            /* object type */
+    unsigned int access;          /* handle access rights */
+@END
-- 
2.49.0


From c40a793fd804ac0d4903b84f0fe06c32a18e46aa Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 19:32:25 +0200
Subject: [PATCH 20/37] server: Introduce select_inproc_queue and
 unselect_inproc_queue requests.

---
 server/protocol.def | 11 +++++++++++
 server/queue.c      | 44 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+)

diff --git a/server/protocol.def b/server/protocol.def
index d601aba464b..47f22ede411 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4277,3 +4277,14 @@ enum inproc_sync_type
     int          type;            /* object type */
     unsigned int access;          /* handle access rights */
 @END
+
+
+/* Begin a client-side wait on a message queue */
+@REQ(select_inproc_queue)
+@END
+
+
+/* End a client-side wait on a message queue */
+@REQ(unselect_inproc_queue)
+    int          signaled;        /* was the queue signaled? */
+@END
diff --git a/server/queue.c b/server/queue.c
index 9e006690720..c13fbc1ac23 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -146,6 +146,7 @@ struct msg_queue
     timeout_t              last_get_msg;    /* time of last get message call */
     int                    keystate_lock;   /* owns an input keystate lock */
     const queue_shm_t     *shared;          /* queue in session shared memory */
+    int                    in_inproc_wait;  /* are we in a client-side wait? */
     struct inproc_sync    *inproc_sync;     /* in-process synchronization object */
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
@@ -340,6 +341,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
         queue->keystate_lock   = 0;
+        queue->in_inproc_wait  = 0;
         queue->inproc_sync     = NULL;
         queue->esync_fd        = -1;
         queue->esync_in_msgwait = 0;
@@ -1317,6 +1319,9 @@ static int is_queue_hung( struct msg_queue *queue )
     if (do_esync() && queue->esync_in_msgwait)
         return 0;   /* thread is waiting on queue in absentia -> not hung */
 
+    if (queue->in_inproc_wait)
+        return 0;  /* thread is waiting on queue in absentia -> not hung */
+
     return 1;
 }
 
@@ -4439,6 +4444,45 @@ DECL_HANDLER(update_rawinput_devices)
     }
 }
 
+DECL_HANDLER(select_inproc_queue)
+{
+    struct msg_queue *queue = current->queue;
+
+    if (queue->in_inproc_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        check_thread_queue_idle( current );
+
+        if (queue->fd)
+            set_fd_events( queue->fd, POLLIN );
+
+        queue->in_inproc_wait = 1;
+    }
+}
+
+DECL_HANDLER(unselect_inproc_queue)
+{
+    struct msg_queue *queue = current->queue;
+
+    if (!queue->in_inproc_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        if (queue->fd)
+            set_fd_events( queue->fd, 0 );
+
+        if (req->signaled)
+            msg_queue_satisfied( &queue->obj, NULL );
+
+        queue->in_inproc_wait = 0;
+    }
+}
+
 DECL_HANDLER(set_keyboard_repeat)
 {
     struct desktop *desktop;
-- 
2.49.0


From 0013252b6ca6691eee262b61e545cc3a52ad9190 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 22 Apr 2022 00:11:14 +0300
Subject: [PATCH 21/37] server: Allow creating an event object for client-side
 user APC signaling.

---
 server/protocol.def |  7 +++++++
 server/thread.c     | 19 +++++++++++++++++++
 server/thread.h     |  1 +
 3 files changed, 27 insertions(+)

diff --git a/server/protocol.def b/server/protocol.def
index 47f22ede411..fe3b9e6a461 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4288,3 +4288,10 @@ enum inproc_sync_type
 @REQ(unselect_inproc_queue)
     int          signaled;        /* was the queue signaled? */
 @END
+
+
+/* Get an event handle to be used for thread alerts with in-process synchronization */
+@REQ(get_inproc_alert_event)
+@REPLY
+    obj_handle_t handle;          /* handle to the event */
+@END
diff --git a/server/thread.c b/server/thread.c
index baf74aa6e56..5475dd88b78 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -314,6 +314,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->desc            = NULL;
     thread->desc_len        = 0;
     thread->inproc_sync     = NULL;
+    thread->inproc_alert_event = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -553,6 +554,7 @@ static void destroy_thread( struct object *obj )
         fsync_free_shm_idx( thread->fsync_apc_idx );
     }
     if (thread->inproc_sync) release_object( thread->inproc_sync );
+    if (thread->inproc_alert_event) release_object( thread->inproc_alert_event );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -1334,6 +1336,9 @@ static int queue_apc( struct process *process, struct thread *thread, struct thr
 
         if (do_esync() && queue == &thread->user_apc)
             esync_wake_fd( thread->esync_apc_fd );
+
+        if (apc->call.type == APC_USER && thread->inproc_alert_event)
+            set_event( thread->inproc_alert_event );
     }
 
     return 1;
@@ -1366,6 +1371,8 @@ void thread_cancel_apc( struct thread *thread, struct object *owner, enum apc_ty
         apc->executed = 1;
         wake_up( &apc->obj, 0 );
         release_object( apc );
+        if (list_empty( &thread->user_apc ) && thread->inproc_alert_event)
+            reset_event( thread->inproc_alert_event );
         return;
     }
 }
@@ -1380,6 +1387,9 @@ static struct thread_apc *thread_dequeue_apc( struct thread *thread, int system
     {
         apc = LIST_ENTRY( ptr, struct thread_apc, entry );
         list_remove( ptr );
+
+        if (list_empty( &thread->user_apc ) && thread->inproc_alert_event)
+            reset_event( thread->inproc_alert_event );
     }
 
     if (do_fsync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
@@ -2286,3 +2296,12 @@ DECL_HANDLER(get_next_thread)
     set_error( STATUS_NO_MORE_ENTRIES );
     release_object( process );
 }
+
+DECL_HANDLER(get_inproc_alert_event)
+{
+    if (!current->inproc_alert_event)
+        current->inproc_alert_event = create_event( NULL, NULL, 0, 1, !list_empty( &current->user_apc ), NULL );
+
+    if (current->inproc_alert_event)
+        reply->handle = alloc_handle( current->process, current->inproc_alert_event, SYNCHRONIZE, 0 );
+}
diff --git a/server/thread.h b/server/thread.h
index 0dae653dea4..4384b79483b 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -98,6 +98,7 @@ struct thread
     WCHAR                 *desc;          /* thread description string */
     struct completion_wait *completion_wait; /* completion port wait object the thread is associated with */
     struct inproc_sync    *inproc_sync;   /* in-process synchronization object */
+    struct event          *inproc_alert_event; /* in-process synchronization alert event */
 };
 
 extern struct thread *current;
-- 
2.49.0


From e4ed404bd1e905282a97066c54ffe1a83330741a Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 02:07:23 +0200
Subject: [PATCH 22/37] ntdll: Introduce a helper to wait on an internal server
 handle.

---
 dlls/ntdll/unix/file.c         |  2 +-
 dlls/ntdll/unix/process.c      |  2 +-
 dlls/ntdll/unix/server.c       | 17 ++++++++++++++++-
 dlls/ntdll/unix/thread.c       |  2 +-
 dlls/ntdll/unix/unix_private.h |  1 +
 5 files changed, 20 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 89aedd2b05c..0754a931d5a 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -7038,7 +7038,7 @@ NTSTATUS WINAPI NtLockFile( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void
         }
         if (handle)
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
             NtClose( handle );
         }
         else  /* Unix lock conflict, sleep a bit and retry */
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index a4957342027..4b1d8e6f1bc 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -920,7 +920,7 @@ NTSTATUS WINAPI NtCreateUserProcess( HANDLE *process_handle_ptr, HANDLE *thread_
 
     /* wait for the new process info to be ready */
 
-    NtWaitForSingleObject( process_info, FALSE, NULL );
+    server_wait_for_object( process_info, FALSE, NULL );
     SERVER_START_REQ( get_new_process_info )
     {
         req->info = wine_server_obj_handle( process_info );
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index c35cf741211..388e5e80c63 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -820,6 +820,21 @@ unsigned int server_wait( const union select_op *select_op, data_size_t size, UI
 }
 
 
+/* helper function to perform a server-side wait on an internal handle without
+ * using the fast synchronization path */
+unsigned int server_wait_for_object( HANDLE handle, BOOL alertable, const LARGE_INTEGER *timeout )
+{
+    union select_op select_op;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (alertable) flags |= SELECT_ALERTABLE;
+
+    select_op.wait.op = SELECT_WAIT;
+    select_op.wait.handles[0] = wine_server_obj_handle( handle );
+    return server_wait( &select_op, offsetof( union select_op, wait.handles[1] ), flags, timeout );
+}
+
+
 /***********************************************************************
  *              NtContinue  (NTDLL.@)
  */
@@ -896,7 +911,7 @@ unsigned int server_queue_process_apc( HANDLE process, const union apc_call *cal
         }
         else
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
 
             SERVER_START_REQ( get_apc_result )
             {
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 5edca5fcf94..95d3a49b1a0 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1846,7 +1846,7 @@ NTSTATUS get_thread_context( HANDLE handle, void *context, BOOL *self, USHORT ma
 
     if (ret == STATUS_PENDING)
     {
-        NtWaitForSingleObject( context_handle, FALSE, NULL );
+        server_wait_for_object( context_handle, FALSE, NULL );
 
         SERVER_START_REQ( get_thread_context )
         {
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index afae39def06..2c4befe18a9 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -227,6 +227,7 @@ extern unsigned int server_select( const union select_op *select_op, data_size_t
                                    timeout_t abs_timeout, struct context_data *context, struct user_apc *user_apc );
 extern unsigned int server_wait( const union select_op *select_op, data_size_t size, UINT flags,
                                  const LARGE_INTEGER *timeout );
+extern unsigned int server_wait_for_object( HANDLE handle, BOOL alertable, const LARGE_INTEGER *timeout );
 extern NTSTATUS wait_internal_server( HANDLE handle, BOOLEAN alertable, const LARGE_INTEGER *timeout );
 extern unsigned int server_queue_process_apc( HANDLE process, const union apc_call *call,
                                               union apc_result *result );
-- 
2.49.0


From a4e92fcf1e3babce99ba79c2ef17813e8d0f9c19 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 9 Mar 2021 20:08:29 +0200
Subject: [PATCH 23/37] ntdll: Add some traces to synchronization methods.

Normally we can rely on +server for these, but with fast synchronization we'll
be skipping the server.
---
 dlls/ntdll/unix/sync.c | 58 ++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 56 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 47fd5b24c46..0fa08dfdc94 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -76,7 +76,8 @@ HANDLE keyed_event = 0;
 static const char *debugstr_timeout( const LARGE_INTEGER *timeout )
 {
     if (!timeout) return "(infinite)";
-    return wine_dbgstr_longlong( timeout->QuadPart );
+    return wine_dbg_sprintf( "%lld.%07ld", (long long)(timeout->QuadPart / TICKSPERSEC),
+                             (long)(timeout->QuadPart % TICKSPERSEC) );
 }
 
 /* return a monotonic time counter, in Win32 ticks */
@@ -313,6 +314,9 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, initial %d, max %d\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", (int)initial, (int)max );
+
     *handle = 0;
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
 
@@ -347,6 +351,8 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJEC
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
 
     if (do_fsync())
@@ -425,6 +431,8 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
     if (do_esync())
         return esync_release_semaphore( handle, count, previous );
 
+    TRACE( "handle %p, count %u, prev_count %p\n", handle, (int)count, previous );
+
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -449,6 +457,9 @@ NTSTATUS WINAPI NtCreateEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u, state %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type, state );
+
     *handle = 0;
     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
 
@@ -483,6 +494,8 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -521,6 +534,8 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
     if (do_esync())
         return esync_set_event( handle );
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -548,6 +563,8 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
         return esync_reset_event( handle );
 
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -583,6 +600,8 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
     if (do_esync())
         return esync_pulse_event( handle );
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -645,6 +664,9 @@ NTSTATUS WINAPI NtCreateMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, owned %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", owned );
+
     *handle = 0;
 
     if (do_fsync())
@@ -677,6 +699,8 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_A
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -714,6 +738,8 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
     if (do_esync())
         return esync_release_mutex( handle, prev_count );
 
+    TRACE( "handle %p, prev_count %p\n", handle, prev_count );
+
     SERVER_START_REQ( release_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1519,6 +1545,9 @@ NTSTATUS WINAPI NtCreateTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type );
+
     *handle = 0;
     if (type != NotificationTimer && type != SynchronizationTimer) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
@@ -1546,6 +1575,8 @@ NTSTATUS WINAPI NtOpenTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -1599,6 +1630,8 @@ NTSTATUS WINAPI NtCancelTimer( HANDLE handle, BOOLEAN *state )
 {
     unsigned int ret;
 
+    TRACE( "handle %p, state %p\n", handle, state );
+
     SERVER_START_REQ( cancel_timer )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1667,6 +1700,7 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
 {
     union select_op select_op;
     UINT i, flags = SELECT_INTERRUPTIBLE;
+    unsigned int ret;
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
@@ -1684,10 +1718,19 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
             return ret;
     }
 
+    if (TRACE_ON(sync))
+    {
+        TRACE( "wait_any %u, alertable %u, handles {%p", wait_any, alertable, handles[0] );
+        for (i = 1; i < count; i++) TRACE( ", %p", handles[i] );
+        TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
+    }
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
-    return server_wait( &select_op, offsetof( union select_op, wait.handles[count] ), flags, timeout );
+    ret = server_wait( &select_op, offsetof( union select_op, wait.handles[count] ), flags, timeout );
+    TRACE( "-> %#x\n", ret );
+    return ret;
 }
 
 
@@ -1725,6 +1768,8 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
     if (do_esync())
         return esync_signal_and_wait( signal, wait, alertable, timeout );
 
+    TRACE( "signal %p, wait %p, alertable %u, timeout %s\n", signal, wait, alertable, debugstr_timeout(timeout) );
+
     if (!signal) return STATUS_INVALID_HANDLE;
 
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -1976,6 +2021,9 @@ NTSTATUS WINAPI NtCreateKeyedEvent( HANDLE *handle, ACCESS_MASK access,
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, flags %#x\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", (int)flags );
+
     *handle = 0;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
@@ -2000,6 +2048,8 @@ NTSTATUS WINAPI NtOpenKeyedEvent( HANDLE *handle, ACCESS_MASK access, const OBJE
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -2026,6 +2076,8 @@ NTSTATUS WINAPI NtWaitForKeyedEvent( HANDLE handle, const void *key,
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -2045,6 +2097,8 @@ NTSTATUS WINAPI NtReleaseKeyedEvent( HANDLE handle, const void *key,
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
-- 
2.49.0


From 5edab23bca4e264602adccabdeb9356880fd5cf6 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 6 Apr 2021 23:37:02 +0300
Subject: [PATCH 24/37] ntdll: Use in-process synchronization objects.

---
 dlls/ntdll/unix/sync.c         | 760 +++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/unix_private.h |   2 +
 dlls/ntdll/unix/virtual.c      |   1 +
 3 files changed, 763 insertions(+)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 0fa08dfdc94..3924699fea1 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -30,9 +30,11 @@
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <inttypes.h>
 #include <limits.h>
 #include <signal.h>
 #include <sys/types.h>
+#include <sys/ioctl.h>
 #include <sys/mman.h>
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
@@ -48,6 +50,7 @@
 #endif
 #include <string.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
@@ -57,6 +60,9 @@
 #ifdef HAVE_KQUEUE
 # include <sys/event.h>
 #endif
+#ifdef HAVE_LINUX_NTSYNC_H
+# include <linux/ntsync.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -304,6 +310,717 @@ static unsigned int validate_open_object_attributes( const OBJECT_ATTRIBUTES *at
 }
 
 
+#ifdef HAVE_LINUX_NTSYNC_H
+
+static int get_linux_sync_device(void)
+{
+    static LONG device = -2;
+
+    if (device == -2)
+    {
+        HANDLE handle;
+        int fd, needs_close;
+        NTSTATUS ret;
+
+        SERVER_START_REQ( get_linux_sync_device )
+        {
+            if (!(ret = wine_server_call( req ))) handle = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if (!ret)
+        {
+            if (!server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL ))
+            {
+                if (InterlockedCompareExchange( &device, fd, -2 ) != -2)
+                {
+                    /* someone beat us to it */
+                    if (needs_close) close( fd );
+                    NtClose( handle );
+                }
+                /* otherwise don't close the device */
+            }
+            else
+            {
+                InterlockedCompareExchange( &device, -1, -2 );
+                NtClose( handle );
+            }
+        }
+        else
+        {
+            InterlockedCompareExchange( &device, -1, -2 );
+        }
+    }
+    return device;
+}
+
+/* It's possible for synchronization primitives to remain alive even after being
+ * closed, because a thread is still waiting on them. It's rare in practice, and
+ * documented as being undefined behaviour by Microsoft, but it works, and some
+ * applications rely on it. This means we need to refcount handles, and defer
+ * deleting them on the server side until the refcount reaches zero. We do this
+ * by having each client process hold a handle to the in-process synchronization
+ * object, as well as a private refcount. When the client refcount reaches zero,
+ * it closes the handle; when all handles are closed, the server deletes the
+ * in-process synchronization object.
+ *
+ * We want lookup of objects from the cache to be very fast; ideally, it should
+ * be lock-free. We achieve this by using atomic modifications to "refcount",
+ * and guaranteeing that all other fields are valid and correct *as long as*
+ * refcount is nonzero, and we store the entire structure in memory which will
+ * never be freed.
+ *
+ * This means that acquiring the object can't use a simple atomic increment; it
+ * has to use a compare-and-swap loop to ensure that it doesn't try to increment
+ * an object with a zero refcount. That's still leagues better than a real lock,
+ * though, and release can be a single atomic decrement.
+ *
+ * It also means that threads modifying the cache need to take a lock, to
+ * prevent other threads from writing to it concurrently.
+ *
+ * It's possible for an object currently in use (by a waiter) to be closed and
+ * the same handle immediately reallocated to a different object. This should be
+ * a very rare situation, and in that case we simply don't cache the handle.
+ */
+struct inproc_sync_cache_entry
+{
+    LONG refcount;
+    int fd;
+    enum inproc_sync_type type;
+    unsigned int access;
+    BOOL closed;
+    /* handle to the underlying in-process sync object, stored as obj_handle_t
+     * to save space */
+    obj_handle_t handle;
+};
+
+
+static void release_inproc_sync_obj( struct inproc_sync_cache_entry *cache )
+{
+    /* save the handle and fd now; as soon as the refcount hits 0 we cannot
+     * access the cache anymore */
+    HANDLE handle = wine_server_ptr_handle( cache->handle );
+    int fd = cache->fd;
+    LONG refcount = InterlockedDecrement( &cache->refcount );
+
+    assert( refcount >= 0 );
+
+    if (!refcount)
+    {
+        NTSTATUS ret = NtClose( handle );
+        assert( !ret );
+        close( fd );
+    }
+}
+
+
+static BOOL inproc_sync_types_match( enum inproc_sync_type a, enum inproc_sync_type b )
+{
+    if (a == b) return TRUE;
+    if (a == INPROC_SYNC_AUTO_EVENT && b == INPROC_SYNC_MANUAL_EVENT) return TRUE;
+    if (b == INPROC_SYNC_AUTO_EVENT && a == INPROC_SYNC_MANUAL_EVENT) return TRUE;
+    return FALSE;
+}
+
+
+/* returns a pointer to a cache entry; if the object could not be cached,
+ * returns "stack_cache" instead, which should be allocated on stack */
+static NTSTATUS get_inproc_sync_obj( HANDLE handle, enum inproc_sync_type desired_type,
+                                     ACCESS_MASK desired_access,
+                                     struct inproc_sync_cache_entry *stack_cache,
+                                     struct inproc_sync_cache_entry **ret_cache )
+{
+    struct inproc_sync_cache_entry *cache = stack_cache;
+    int needs_close;
+    NTSTATUS ret;
+
+    *ret_cache = stack_cache;
+
+    SERVER_START_REQ( get_linux_sync_obj )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            cache->handle = reply->handle;
+            cache->access = reply->access;
+            cache->type = reply->type;
+            cache->refcount = 1;
+            cache->closed = FALSE;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret) return ret;
+
+    if ((ret = server_get_unix_fd( wine_server_ptr_handle( cache->handle ),
+                                   0, &cache->fd, &needs_close, NULL, NULL )))
+        return ret;
+
+    if (desired_type && !inproc_sync_types_match( cache->type, desired_type ))
+    {
+        release_inproc_sync_obj( cache );
+        return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if ((cache->access & desired_access) != desired_access)
+    {
+        release_inproc_sync_obj( cache );
+        return STATUS_ACCESS_DENIED;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS linux_release_semaphore_obj( int obj, ULONG count, ULONG *prev_count )
+{
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_SEM_RELEASE, &count );
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_SEMAPHORE,
+                                    SEMAPHORE_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_release_semaphore_obj( cache->fd, count, prev_count );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_semaphore_obj( int obj, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct ntsync_sem_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_SEM_READ, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->CurrentCount = args.count;
+    info->MaximumCount = args.max;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_SEMAPHORE,
+                                    SEMAPHORE_QUERY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_semaphore_obj( cache->fd, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_set_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_SET, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_set_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_set_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_reset_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_RESET, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_reset_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_reset_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_pulse_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_PULSE, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_pulse_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_event_obj( int obj, enum inproc_sync_type type, EVENT_BASIC_INFORMATION *info )
+{
+    struct ntsync_event_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_READ, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->EventType = (type == INPROC_SYNC_AUTO_EVENT) ? SynchronizationEvent : NotificationEvent;
+    info->EventState = args.signaled;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_QUERY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_event_obj( cache->fd, cache->type, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_release_mutex_obj( int obj, LONG *prev_count )
+{
+    struct ntsync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    args.owner = GetCurrentThreadId();
+    ret = ioctl( obj, NTSYNC_IOC_MUTEX_UNLOCK, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_MUTANT_LIMIT_EXCEEDED;
+        else if (errno == EPERM)
+            return STATUS_MUTANT_NOT_OWNED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_MUTEX, 0, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_release_mutex_obj( cache->fd, prev_count );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_mutex_obj( int obj, MUTANT_BASIC_INFORMATION *info )
+{
+    struct ntsync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_MUTEX_READ, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOWNERDEAD)
+        {
+            info->AbandonedState = TRUE;
+            info->OwnedByCaller = FALSE;
+            info->CurrentCount = 1;
+            return STATUS_SUCCESS;
+        }
+        else
+            return errno_to_status( errno );
+    }
+    info->AbandonedState = FALSE;
+    info->OwnedByCaller = (args.owner == GetCurrentThreadId());
+    info->CurrentCount = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_MUTEX, MUTANT_QUERY_STATE,
+                                    &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_mutex_obj( cache->fd, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+static void select_queue(void)
+{
+    SERVER_START_REQ( select_inproc_queue )
+    {
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static void unselect_queue( BOOL signaled )
+{
+    SERVER_START_REQ( unselect_inproc_queue )
+    {
+        req->signaled = signaled;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static int get_inproc_alert_obj(void)
+{
+    struct ntdll_thread_data *data = ntdll_get_thread_data();
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    HANDLE alert_handle;
+    unsigned int ret;
+
+    if (data->linux_alert_obj == -1)
+    {
+        SERVER_START_REQ( get_inproc_alert_event )
+        {
+            if ((ret = wine_server_call( req )))
+                ERR( "failed to get inproc alert event, status %#x\n", ret );
+            alert_handle = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if ((ret = get_inproc_sync_obj( alert_handle, 0, SYNCHRONIZE, &stack_cache, &cache )))
+            ERR( "failed to get inproc alert obj, status %#x\n", ret );
+        data->linux_alert_obj = cache->fd;
+        /* Set the fd to -1 so release_inproc_sync_obj() won't close it.
+         * Manhandling the cache entry here is fine since we're the only thread
+         * that can access our own alert event. */
+        cache->fd = -1;
+        release_inproc_sync_obj( cache );
+        NtClose( alert_handle );
+    }
+
+    return data->linux_alert_obj;
+}
+
+static NTSTATUS linux_wait_objs( int device, const DWORD count, const int *objs,
+                                 BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct ntsync_wait_args args = {0};
+    unsigned long request;
+    struct timespec now;
+    int ret;
+
+    if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)
+    {
+        args.timeout = ~(__u64)0;
+    }
+    else if (timeout->QuadPart <= 0)
+    {
+        clock_gettime( CLOCK_MONOTONIC, &now );
+        args.timeout = (now.tv_sec * NSECPERSEC) + now.tv_nsec + (-timeout->QuadPart * 100);
+    }
+    else
+    {
+        args.timeout = (timeout->QuadPart * 100) - (SECS_1601_TO_1970 * NSECPERSEC);
+        args.flags |= NTSYNC_WAIT_REALTIME;
+    }
+
+    args.objs = (uintptr_t)objs;
+    args.count = count;
+    args.owner = GetCurrentThreadId();
+    args.index = ~0u;
+
+    if (alertable)
+        args.alert = get_inproc_alert_obj();
+
+    if (wait_any || count == 1)
+        request = NTSYNC_IOC_WAIT_ANY;
+    else
+        request = NTSYNC_IOC_WAIT_ALL;
+
+    do
+    {
+        ret = ioctl( device, request, &args );
+    } while (ret < 0 && errno == EINTR);
+
+    if (!ret)
+    {
+        if (args.index == count)
+        {
+            static const LARGE_INTEGER timeout;
+
+            ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &timeout );
+            assert( ret == STATUS_USER_APC );
+            return ret;
+        }
+
+        return wait_any ? args.index : 0;
+    }
+    else if (errno == EOWNERDEAD)
+        return STATUS_ABANDONED + (wait_any ? args.index : 0);
+    else if (errno == ETIMEDOUT)
+        return STATUS_TIMEOUT;
+    else
+        return errno_to_status( errno );
+}
+
+static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct inproc_sync_cache_entry stack_cache[64], *cache[64];
+    int device, objs[64];
+    HANDLE queue = NULL;
+    NTSTATUS ret;
+    DWORD i, j;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    for (i = 0; i < count; ++i)
+    {
+        if ((ret = get_inproc_sync_obj( handles[i], 0, SYNCHRONIZE, &stack_cache[i], &cache[i] )))
+        {
+            for (j = 0; j < i; ++j)
+                release_inproc_sync_obj( cache[j] );
+            return ret;
+        }
+        if (cache[i]->type == INPROC_SYNC_QUEUE)
+            queue = handles[i];
+
+        objs[i] = cache[i]->fd;
+    }
+
+    if (queue) select_queue();
+
+    ret = linux_wait_objs( device, count, objs, wait_any, alertable, timeout );
+
+    if (queue) unselect_queue( handles[ret] == queue );
+
+    for (i = 0; i < count; ++i)
+        release_inproc_sync_obj( cache[i] );
+
+    return ret;
+}
+
+static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
+                                        BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct inproc_sync_cache_entry signal_stack_cache, *signal_cache;
+    struct inproc_sync_cache_entry wait_stack_cache, *wait_cache;
+    HANDLE queue = NULL;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_inproc_sync_obj( signal, 0, 0, &signal_stack_cache, &signal_cache )))
+        return ret;
+
+    switch (signal_cache->type)
+    {
+        case INPROC_SYNC_SEMAPHORE:
+            if (!(signal_cache->access & SEMAPHORE_MODIFY_STATE))
+            {
+                release_inproc_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case INPROC_SYNC_AUTO_EVENT:
+        case INPROC_SYNC_MANUAL_EVENT:
+            if (!(signal_cache->access & EVENT_MODIFY_STATE))
+            {
+                release_inproc_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case INPROC_SYNC_MUTEX:
+            break;
+
+        default:
+            /* can't be signaled */
+            release_inproc_sync_obj( signal_cache );
+            return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if ((ret = get_inproc_sync_obj( wait, 0, SYNCHRONIZE, &wait_stack_cache, &wait_cache )))
+    {
+        release_inproc_sync_obj( signal_cache );
+        return ret;
+    }
+
+    if (wait_cache->type == INPROC_SYNC_QUEUE)
+        queue = wait;
+
+    switch (signal_cache->type)
+    {
+        case INPROC_SYNC_SEMAPHORE:
+            ret = linux_release_semaphore_obj( signal_cache->fd, 1, NULL );
+            break;
+
+        case INPROC_SYNC_AUTO_EVENT:
+        case INPROC_SYNC_MANUAL_EVENT:
+            ret = linux_set_event_obj( signal_cache->fd, NULL );
+            break;
+
+        case INPROC_SYNC_MUTEX:
+            ret = linux_release_mutex_obj( signal_cache->fd, NULL );
+            break;
+
+        default:
+            assert( 0 );
+            break;
+    }
+
+    if (!ret)
+    {
+        if (queue) select_queue();
+        ret = linux_wait_objs( device, 1, &wait_cache->fd, TRUE, alertable, timeout );
+        if (queue) unselect_queue( !ret );
+    }
+
+    release_inproc_sync_obj( signal_cache );
+    release_inproc_sync_obj( wait_cache );
+    return ret;
+}
+
+#else
+
+static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_set_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_reset_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
+                                        BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif
+
+
 /******************************************************************************
  *              NtCreateSemaphore (NTDLL.@)
  */
@@ -403,6 +1120,12 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
     if (do_esync())
         return esync_query_semaphore( handle, info, ret_len );
 
+    if ((ret = inproc_query_semaphore( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(SEMAPHORE_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -433,6 +1156,9 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
 
     TRACE( "handle %p, count %u, prev_count %p\n", handle, (int)count, previous );
 
+    if ((ret = inproc_release_semaphore( handle, count, previous )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -536,6 +1262,9 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = inproc_set_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -565,6 +1294,9 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = inproc_reset_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -602,6 +1334,9 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = inproc_pulse_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -639,6 +1374,12 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
     if (do_esync())
         return esync_query_event( handle, info, ret_len );
 
+    if ((ret = inproc_query_event( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(EVENT_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_event )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -740,6 +1481,9 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
 
     TRACE( "handle %p, prev_count %p\n", handle, prev_count );
 
+    if ((ret = inproc_release_mutex( handle, prev_count )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     SERVER_START_REQ( release_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -776,6 +1520,12 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
     if (do_esync())
         return esync_query_mutex( handle, info, ret_len );
 
+    if ((ret = inproc_query_mutex( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(MUTANT_BASIC_INFORMATION);
+        return ret;
+    }
+
     SERVER_START_REQ( query_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1725,6 +2475,12 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
         TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
     }
 
+    if ((ret = inproc_wait( count, handles, wait_any, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+    {
+        TRACE( "-> %#x\n", ret );
+        return ret;
+    }
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
@@ -1761,6 +2517,7 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 {
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
+    NTSTATUS ret;
 
     if (do_fsync())
         return fsync_signal_and_wait( signal, wait, alertable, timeout );
@@ -1772,6 +2529,9 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 
     if (!signal) return STATUS_INVALID_HANDLE;
 
+    if ((ret = inproc_signal_and_wait( signal, wait, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.signal_and_wait.op = SELECT_SIGNAL_AND_WAIT;
     select_op.signal_and_wait.wait = wine_server_obj_handle( wait );
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 2c4befe18a9..3a3711d0b85 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -114,6 +114,7 @@ struct ntdll_thread_data
     PRTL_THREAD_START_ROUTINE start;  /* thread entry point */
     void              *param;         /* thread entry point parameter */
     void              *jmp_buf;       /* setjmp buffer for exception handling */
+    int                linux_alert_obj; /* fd for the linux in-process alert event */
 };
 
 C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
@@ -411,6 +412,7 @@ extern void call_raise_user_exception_dispatcher(void);
 extern const char * wine_debuginfostr_pc(void *pc);
 
 #define TICKSPERSEC 10000000
+#define NSECPERSEC 1000000000
 #define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)86400)
 
 static inline ULONGLONG ticks_from_time_t( time_t time )
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index f1f200b5bf4..e2566795108 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -4173,6 +4173,7 @@ static TEB *init_teb( void *ptr, BOOL is_wow )
     thread_data->reply_fd   = -1;
     thread_data->wait_fd[0] = -1;
     thread_data->wait_fd[1] = -1;
+    thread_data->linux_alert_obj = -1;
     list_add_head( &teb_list, &thread_data->entry );
     return teb;
 }
-- 
2.49.0


From 7ba7d74c12aee8dccd5f66f97ec3e56bd63dbfec Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 20 Apr 2021 17:55:59 -0500
Subject: [PATCH 25/37] ntdll: Use server_wait_for_object() when waiting on
 only the queue object.

---
 dlls/ntdll/unix/sync.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 3924699fea1..3300f3d56cb 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -868,6 +868,17 @@ static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_an
         objs[i] = cache[i]->fd;
     }
 
+    /* It's common to wait on the message queue alone. Some applications wait
+     * on it in fast paths, with a zero timeout. Since we take two server calls
+     * instead of one when going through inproc_wait(), and since we only need
+     * to go through that path if we're waiting on other objects, just delegate
+     * to the server if we're only waiting on the message queue. */
+    if (count == 1 && queue)
+    {
+        release_inproc_sync_obj( cache[0] );
+        return server_wait_for_object( handles[0], alertable, timeout );
+    }
+
     if (queue) select_queue();
 
     ret = linux_wait_objs( device, count, objs, wait_any, alertable, timeout );
-- 
2.49.0


From d2ddf450fed32c881c01f62fb97d76241a5be79e Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 12 Mar 2021 23:04:17 +0200
Subject: [PATCH 26/37] ntdll: Cache in-process synchronization objects.

---
 dlls/ntdll/unix/server.c       |   9 ++
 dlls/ntdll/unix/sync.c         | 195 +++++++++++++++++++++++++++++++--
 dlls/ntdll/unix/unix_private.h |   4 +
 3 files changed, 197 insertions(+), 11 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 388e5e80c63..e725e9b0301 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1868,12 +1868,17 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE
         return result.dup_handle.status;
     }
 
+    /* hold fd_cache_mutex to prevent the fd from being added again between the
+     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
      * retrieve it again */
     if (options & DUPLICATE_CLOSE_SOURCE)
+    {
         fd = remove_fd_from_cache( source );
+        close_inproc_sync_obj( source );
+    }
 
     SERVER_START_REQ( dup_handle )
     {
@@ -1939,6 +1944,8 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
     if (HandleToLong( handle ) >= ~5 && HandleToLong( handle ) <= ~0)
         return STATUS_SUCCESS;
 
+    /* hold fd_cache_mutex to prevent the fd from being added again between the
+     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
@@ -1951,6 +1958,8 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
     if (do_esync())
         esync_close( handle );
 
+    close_inproc_sync_obj( handle );
+
     SERVER_START_REQ( close_handle )
     {
         req->handle = wine_server_obj_handle( handle );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 3300f3d56cb..846d8b6f37d 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -364,6 +364,12 @@ static int get_linux_sync_device(void)
  * it closes the handle; when all handles are closed, the server deletes the
  * in-process synchronization object.
  *
+ * We also need this for signal-and-wait. The signal and wait operations aren't
+ * atomic, but we can't perform the signal and then return STATUS_INVALID_HANDLE
+ * for the wait—we need to either do both operations or neither. That means we
+ * need to grab references to both objects, and prevent them from being
+ * destroyed before we're done with them.
+ *
  * We want lookup of objects from the cache to be very fast; ideally, it should
  * be lock-free. We achieve this by using atomic modifications to "refcount",
  * and guaranteeing that all other fields are valid and correct *as long as*
@@ -407,13 +413,140 @@ static void release_inproc_sync_obj( struct inproc_sync_cache_entry *cache )
 
     if (!refcount)
     {
-        NTSTATUS ret = NtClose( handle );
+        NTSTATUS ret;
+
+        /* we can't call NtClose here as we may be inside fd_cache_mutex */
+        SERVER_START_REQ( close_handle )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+
         assert( !ret );
         close( fd );
     }
 }
 
 
+#define INPROC_SYNC_CACHE_BLOCK_SIZE  (65536 / sizeof(struct inproc_sync_cache_entry))
+#define INPROC_SYNC_CACHE_ENTRIES     128
+
+static struct inproc_sync_cache_entry *inproc_sync_cache[INPROC_SYNC_CACHE_ENTRIES];
+static struct inproc_sync_cache_entry inproc_sync_cache_initial_block[INPROC_SYNC_CACHE_BLOCK_SIZE];
+
+static inline unsigned int inproc_sync_handle_to_index( HANDLE handle, unsigned int *entry )
+{
+    unsigned int idx = (wine_server_obj_handle(handle) >> 2) - 1;
+    *entry = idx / INPROC_SYNC_CACHE_BLOCK_SIZE;
+    return idx % INPROC_SYNC_CACHE_BLOCK_SIZE;
+}
+
+
+static struct inproc_sync_cache_entry *cache_inproc_sync_obj( HANDLE handle, obj_handle_t inproc_sync, int fd,
+                                                              enum inproc_sync_type type, unsigned int access )
+{
+    unsigned int entry, idx = inproc_sync_handle_to_index( handle, &entry );
+    struct inproc_sync_cache_entry *cache;
+    sigset_t sigset;
+    int refcount;
+
+    if (entry >= INPROC_SYNC_CACHE_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return NULL;
+    }
+
+    if (!inproc_sync_cache[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) inproc_sync_cache[0] = inproc_sync_cache_initial_block;
+        else
+        {
+            static const size_t size = INPROC_SYNC_CACHE_BLOCK_SIZE * sizeof(struct inproc_sync_cache_entry);
+            void *ptr = anon_mmap_alloc( size, PROT_READ | PROT_WRITE );
+            if (ptr == MAP_FAILED) return NULL;
+            if (InterlockedCompareExchangePointer( (void **)&inproc_sync_cache[entry], ptr, NULL ))
+                munmap( ptr, size ); /* someone beat us to it */
+        }
+    }
+
+    cache = &inproc_sync_cache[entry][idx];
+
+    /* Hold fd_cache_mutex instead of a separate mutex, to prevent the same
+     * race between this function and NtClose. That is, prevent the object from
+     * being cached again between close_inproc_sync_obj() and close_handle. */
+    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    if (InterlockedCompareExchange( &cache->refcount, 0, 0 ))
+    {
+        /* We lost the race with another thread trying to cache this object, or
+         * the handle is currently being used for another object (i.e. it was
+         * closed and then reused). We have no way of knowing which, and in the
+         * latter case we can't cache this object until the old one is
+         * completely destroyed, so always return failure. */
+        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+        return NULL;
+    }
+
+    cache->handle = inproc_sync;
+    cache->fd = fd;
+    cache->type = type;
+    cache->access = access;
+    cache->closed = FALSE;
+    /* Make sure we set the other members before the refcount; this store needs
+     * release semantics [paired with the load in get_cached_inproc_sync_obj()].
+     * Set the refcount to 2 (one for the handle, one for the caller). */
+    refcount = InterlockedExchange( &cache->refcount, 2 );
+    assert( !refcount );
+
+    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    return cache;
+}
+
+
+/* returns the previous value */
+static inline LONG interlocked_inc_if_nonzero( LONG *dest )
+{
+    LONG val, tmp;
+    for (val = *dest;; val = tmp)
+    {
+        if (!val || (tmp = InterlockedCompareExchange( dest, val + 1, val )) == val)
+            break;
+    }
+    return val;
+}
+
+
+static struct inproc_sync_cache_entry *get_cached_inproc_sync_obj( HANDLE handle )
+{
+    unsigned int entry, idx = inproc_sync_handle_to_index( handle, &entry );
+    struct inproc_sync_cache_entry *cache;
+
+    if (entry >= INPROC_SYNC_CACHE_ENTRIES || !inproc_sync_cache[entry])
+        return NULL;
+
+    cache = &inproc_sync_cache[entry][idx];
+
+    /* this load needs acquire semantics [paired with the store in
+     * cache_inproc_sync_obj()] */
+    if (!interlocked_inc_if_nonzero( &cache->refcount ))
+        return NULL;
+
+    if (cache->closed)
+    {
+        /* The object is still being used, but "handle" has been closed. The
+         * handle value might have been reused for another object in the
+         * meantime, in which case we have to report that valid object, so
+         * force the caller to check the server. */
+        release_inproc_sync_obj( cache );
+        return NULL;
+    }
+
+    return cache;
+}
+
+
 static BOOL inproc_sync_types_match( enum inproc_sync_type a, enum inproc_sync_type b )
 {
     if (a == b) return TRUE;
@@ -430,32 +563,53 @@ static NTSTATUS get_inproc_sync_obj( HANDLE handle, enum inproc_sync_type desire
                                      struct inproc_sync_cache_entry *stack_cache,
                                      struct inproc_sync_cache_entry **ret_cache )
 {
-    struct inproc_sync_cache_entry *cache = stack_cache;
-    int needs_close;
+    struct inproc_sync_cache_entry *cache;
+    obj_handle_t inproc_sync_handle;
+    enum inproc_sync_type type;
+    unsigned int access;
+    int fd, needs_close;
     NTSTATUS ret;
 
-    *ret_cache = stack_cache;
+    /* try to find it in the cache already */
+    if ((cache = get_cached_inproc_sync_obj( handle )))
+    {
+        *ret_cache = cache;
+        return STATUS_SUCCESS;
+    }
 
+    /* try to retrieve it from the server */
     SERVER_START_REQ( get_linux_sync_obj )
     {
         req->handle = wine_server_obj_handle( handle );
         if (!(ret = wine_server_call( req )))
         {
-            cache->handle = reply->handle;
-            cache->access = reply->access;
-            cache->type = reply->type;
-            cache->refcount = 1;
-            cache->closed = FALSE;
+            inproc_sync_handle = reply->handle;
+            access = reply->access;
+            type = reply->type;
         }
     }
     SERVER_END_REQ;
 
     if (ret) return ret;
 
-    if ((ret = server_get_unix_fd( wine_server_ptr_handle( cache->handle ),
-                                   0, &cache->fd, &needs_close, NULL, NULL )))
+    if ((ret = server_get_unix_fd( wine_server_ptr_handle( inproc_sync_handle ),
+                                   0, &fd, &needs_close, NULL, NULL )))
         return ret;
 
+    cache = cache_inproc_sync_obj( handle, inproc_sync_handle, fd, type, access );
+    if (!cache)
+    {
+        cache = stack_cache;
+        cache->handle = inproc_sync_handle;
+        cache->fd = fd;
+        cache->type = type;
+        cache->access = access;
+        cache->closed = FALSE;
+        cache->refcount = 1;
+    }
+
+    *ret_cache = cache;
+
     if (desired_type && !inproc_sync_types_match( cache->type, desired_type ))
     {
         release_inproc_sync_obj( cache );
@@ -472,6 +626,21 @@ static NTSTATUS get_inproc_sync_obj( HANDLE handle, enum inproc_sync_type desire
 }
 
 
+/* caller must hold fd_cache_mutex */
+void close_inproc_sync_obj( HANDLE handle )
+{
+    struct inproc_sync_cache_entry *cache = get_cached_inproc_sync_obj( handle );
+
+    if (cache)
+    {
+        cache->closed = TRUE;
+        /* once for the reference we just grabbed, and once for the handle */
+        release_inproc_sync_obj( cache );
+        release_inproc_sync_obj( cache );
+    }
+}
+
+
 static NTSTATUS linux_release_semaphore_obj( int obj, ULONG count, ULONG *prev_count )
 {
     NTSTATUS ret;
@@ -977,6 +1146,10 @@ static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
 
 #else
 
+void close_inproc_sync_obj( HANDLE handle )
+{
+}
+
 static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
 {
     return STATUS_NOT_IMPLEMENTED;
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 3a3711d0b85..962a47f436c 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -221,6 +221,8 @@ extern NTSTATUS load_start_exe( WCHAR **image, void **module );
 extern ULONG_PTR redirect_arm64ec_rva( void *module, ULONG_PTR rva, const IMAGE_ARM64EC_METADATA *metadata );
 extern void start_server( BOOL debug );
 
+extern pthread_mutex_t fd_cache_mutex;
+
 extern unsigned int server_call_unlocked( void *req_ptr );
 extern void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset );
 extern void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset );
@@ -402,6 +404,8 @@ extern NTSTATUS wow64_wine_spawnvp( void *args );
 
 extern void dbg_init(void);
 
+extern void close_inproc_sync_obj( HANDLE handle );
+
 extern NTSTATUS call_user_apc_dispatcher( CONTEXT *context_ptr, ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
                                           PNTAPCFUNC func, NTSTATUS status );
 extern NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context );
-- 
2.49.0


From 35be6daa6a4c9aea7c7345c9b1fdb70551858a69 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sat, 13 Mar 2021 16:20:30 -0600
Subject: [PATCH 27/37] server: Allow disabling in-process synchronization
 support.

---
 server/inproc_sync.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 6cb02b16832..fb9d2442c02 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -128,6 +128,12 @@ static struct linux_device *get_linux_device(void)
     struct linux_device *device;
     int unix_fd;
 
+    if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
+    {
+        set_error( STATUS_NOT_IMPLEMENTED );
+        return NULL;
+    }
+
     if (linux_device_object)
         return (struct linux_device *)grab_object( linux_device_object );
 
-- 
2.49.0


From 67ab4a690b1f8ebcaec7d1155a63e11ffdf0beae Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sun, 14 Mar 2021 11:08:02 -0500
Subject: [PATCH 28/37] server: Add a message to signal that in-proces
 synchronization is indeed active.

---
 server/inproc_sync.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index fb9d2442c02..1c67eba245f 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -157,6 +157,7 @@ static struct linux_device *get_linux_device(void)
         return NULL;
     }
 
+    fprintf( stderr, "wine: using fast synchronization.\n" );
     linux_device_object = device;
     return device;
 }
-- 
2.49.0


From c295f9c9975a4fa4ddf1ae27c8bfd121c25a4e59 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 3 May 2024 14:35:50 -0400
Subject: [PATCH 29/37] extra debugging

---
 server/inproc_sync.c | 23 ++++++++++++++++++++---
 1 file changed, 20 insertions(+), 3 deletions(-)

diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 1c67eba245f..a2781ac293c 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -21,6 +21,7 @@
 #include "config.h"
 
 #include <assert.h>
+#include <errno.h>
 #include <stdint.h>
 #include <stdio.h>
 
@@ -126,21 +127,34 @@ static enum server_fd_type inproc_sync_get_fd_type( struct fd *fd )
 static struct linux_device *get_linux_device(void)
 {
     struct linux_device *device;
+    static int initialized;
     int unix_fd;
 
+    if (initialized)
+    {
+        if (linux_device_object)
+            grab_object( linux_device_object );
+	else
+	  set_error( STATUS_NOT_IMPLEMENTED );
+        return linux_device_object;
+    }
+
     if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
     {
+      static int once;
         set_error( STATUS_NOT_IMPLEMENTED );
+	if (!once++) fprintf(stderr, "ntsync is explicitly disabled.\n");
+	initialized = 1;
         return NULL;
     }
 
-    if (linux_device_object)
-        return (struct linux_device *)grab_object( linux_device_object );
-
     unix_fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
     if (unix_fd == -1)
     {
+      static int once;
         file_set_error();
+	if (!once++) fprintf(stderr, "Cannot open /dev/ntsync: %s\n", strerror(errno));
+	initialized = 1;
         return NULL;
     }
 
@@ -148,17 +162,20 @@ static struct linux_device *get_linux_device(void)
     {
         close( unix_fd );
         set_error( STATUS_NO_MEMORY );
+	initialized = 1;
         return NULL;
     }
 
     if (!(device->fd = create_anonymous_fd( &inproc_sync_fd_ops, unix_fd, &device->obj, 0 )))
     {
         release_object( device );
+	initialized = 1;
         return NULL;
     }
 
     fprintf( stderr, "wine: using fast synchronization.\n" );
     linux_device_object = device;
+    initialized = 1;
     return device;
 }
 
-- 
2.49.0


From e2775686a5758ad6c297068a516ae22384b26c09 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sun, 15 Dec 2024 01:59:50 +0200
Subject: [PATCH 30/37] ntsync: disable esync and fsync when ntsync is enabled

---
 dlls/ntdll/unix/esync.c | 3 ++-
 dlls/ntdll/unix/fsync.c | 3 ++-
 server/esync.c          | 3 ++-
 server/fsync.c          | 3 ++-
 server/main.c           | 3 +++
 5 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index ec3aff489a5..22856231bc0 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -57,7 +57,8 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync();
+        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync() &&
+                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
 
     return do_esync_cached;
 #else
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index beebe520e4c..2aa402a57b2 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -171,7 +171,8 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, NULL, 0, 0, NULL, 0 );
-        do_fsync_cached = !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) && errno != ENOSYS;
+        do_fsync_cached = errno != ENOSYS && !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) &&
+                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
     }
 
     return do_fsync_cached;
diff --git a/server/esync.c b/server/esync.c
index 586ecc08059..fa73a4651ee 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -51,7 +51,8 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync();
+        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync() &&
+                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
 
     return do_esync_cached;
 #else
diff --git a/server/fsync.c b/server/fsync.c
index 0fbfc690a66..d8c5dced58b 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -59,7 +59,8 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, 0, 0, 0, 0, 0);
-        do_fsync_cached = !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) && errno != ENOSYS;
+        do_fsync_cached = errno != ENOSYS && !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) &&
+                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
     }
 
     return do_fsync_cached;
diff --git a/server/main.c b/server/main.c
index d0a0a4879b5..d0ac24b0a1f 100644
--- a/server/main.c
+++ b/server/main.c
@@ -231,6 +231,8 @@ int main( int argc, char *argv[] )
 
     sock_init();
     open_master_socket();
+    if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
+    {
 
     if (do_fsync())
         fsync_init();
@@ -240,6 +242,7 @@ int main( int argc, char *argv[] )
 
     if (!do_fsync() && !do_esync())
         fprintf( stderr, "wineserver: using server-side synchronization.\n" );
+    }
 
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
-- 
2.49.0


From 9fa6a838118e6bc7527f4fa8892faa108a3b3ed0 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Mon, 10 Feb 2025 12:55:36 -0800
Subject: [PATCH 31/37] fixup! HACK: win32u: Always call get_message request
 after waiting.

---
 dlls/ntdll/unix/esync.c      |  2 +-
 dlls/ntdll/unix/esync.h      |  2 +-
 dlls/ntdll/unix/fsync.c      |  2 +-
 dlls/ntdll/unix/fsync.h      |  2 +-
 dlls/win32u/message.c        | 12 +++++++++++-
 dlls/win32u/win32u_private.h |  3 +++
 6 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 22856231bc0..0e924e199bb 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -51,7 +51,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(esync);
 
-int do_esync(void)
+NTSTATUS do_esync(void)
 {
 #ifdef HAVE_SYS_EVENTFD_H
     static int do_esync_cached = -1;
diff --git a/dlls/ntdll/unix/esync.h b/dlls/ntdll/unix/esync.h
index 59f8809fc1a..9ab45d47fa6 100644
--- a/dlls/ntdll/unix/esync.h
+++ b/dlls/ntdll/unix/esync.h
@@ -18,7 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-extern int do_esync(void);
+extern NTSYSAPI NTSTATUS do_esync( void );
 extern void esync_init(void);
 extern NTSTATUS esync_close( HANDLE handle );
 
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 2aa402a57b2..3736a0808ad 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -163,7 +163,7 @@ static inline int futex_wake( int *addr, int val )
     return syscall( __NR_futex, addr, 1, val, NULL, 0, 0 );
 }
 
-int do_fsync(void)
+NTSTATUS do_fsync(void)
 {
 #ifdef __linux__
     static int do_fsync_cached = -1;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 6005c0fa322..4d87e4f02b6 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -18,7 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-extern int do_fsync(void);
+extern NTSYSAPI NTSTATUS do_fsync( void );
 extern void fsync_init(void);
 extern NTSTATUS fsync_close( HANDLE handle );
 
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 9331e928aa2..4d4431eab34 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -2796,6 +2796,16 @@ static BOOL check_queue_bits( UINT wake_mask, UINT changed_mask, UINT signal_bit
     return skip;
 }
 
+static inline BOOL using_server_or_ntsync(void)
+{
+    static int server_or_nt_cached = -1;
+    if (server_or_nt_cached == -1)
+    {
+        server_or_nt_cached = !(do_esync() || do_fsync());
+    }
+    return !!server_or_nt_cached;
+}
+
 /***********************************************************************
  *           peek_message
  *
@@ -2843,7 +2853,7 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
         thread_info->client_info.msg_source = prev_source;
         wake_mask = filter->mask & (QS_SENDMESSAGE | QS_SMRESULT);
 
-        if (!filter->waited && NtGetTickCount() - thread_info->last_getmsg_time < 3000 && /* avoid hung queue */
+        if ((using_server_or_ntsync() || !filter->waited) && NtGetTickCount() - thread_info->last_getmsg_time < 3000 && /* avoid hung queue */
             check_queue_bits( wake_mask, filter->mask, wake_mask | signal_bits, filter->mask | clear_bits,
                               &wake_bits, &changed_bits ))
             res = STATUS_PENDING;
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index f9b812ff70c..8ba5771d2f3 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -323,6 +323,9 @@ extern const struct user_driver_funcs *user_driver;
 
 extern ULONG_PTR zero_bits;
 
+extern NTSTATUS do_esync( void );
+extern NTSTATUS do_fsync( void );
+
 static inline BOOL set_ntstatus( NTSTATUS status )
 {
     if (status) RtlSetLastWin32Error( RtlNtStatusToDosError( status ));
-- 
2.49.0


From 4a8b1dfc335b9a8ef05fba12c61f7c1ac36115b6 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Thu, 26 Dec 2024 07:00:02 -0800
Subject: [PATCH 32/37] ntdll: Increase cache entries to 256.

Match esync/fsync size to reduce 'too many allocated handles, not caching'.
---
 dlls/ntdll/unix/server.c | 2 +-
 dlls/ntdll/unix/sync.c   | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index e725e9b0301..80c603068b5 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1044,7 +1044,7 @@ union fd_cache_entry
 C_ASSERT( sizeof(union fd_cache_entry) == sizeof(LONG64) );
 
 #define FD_CACHE_BLOCK_SIZE  (65536 / sizeof(union fd_cache_entry))
-#define FD_CACHE_ENTRIES     128
+#define FD_CACHE_ENTRIES     256
 
 static union fd_cache_entry *fd_cache[FD_CACHE_ENTRIES];
 static union fd_cache_entry fd_cache_initial_block[FD_CACHE_BLOCK_SIZE];
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 846d8b6f37d..25ee0f59e62 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -430,7 +430,7 @@ static void release_inproc_sync_obj( struct inproc_sync_cache_entry *cache )
 
 
 #define INPROC_SYNC_CACHE_BLOCK_SIZE  (65536 / sizeof(struct inproc_sync_cache_entry))
-#define INPROC_SYNC_CACHE_ENTRIES     128
+#define INPROC_SYNC_CACHE_ENTRIES     256
 
 static struct inproc_sync_cache_entry *inproc_sync_cache[INPROC_SYNC_CACHE_ENTRIES];
 static struct inproc_sync_cache_entry inproc_sync_cache_initial_block[INPROC_SYNC_CACHE_BLOCK_SIZE];
-- 
2.49.0


From 832d16310af5c09587262f3f65da20c3eacac750 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Mon, 23 Dec 2024 11:31:27 +0200
Subject: [PATCH 33/37] include: use ntsync.h v7 module header as an in-tree
 header

---
 configure.ac           |  1 -
 dlls/ntdll/unix/sync.c |  4 +--
 include/Makefile.in    |  1 +
 include/ntsync.h       | 61 ++++++++++++++++++++++++++++++++++++++++++
 server/inproc_sync.c   |  4 ++-
 5 files changed, 67 insertions(+), 4 deletions(-)
 create mode 100644 include/ntsync.h

diff --git a/configure.ac b/configure.ac
index 2a5808b65d7..d4e999fb727 100644
--- a/configure.ac
+++ b/configure.ac
@@ -387,7 +387,6 @@ AC_CHECK_HEADERS(\
 	linux/input.h \
 	linux/ioctl.h \
 	linux/major.h \
-	linux/ntsync.h \
 	linux/param.h \
 	linux/seccomp.h \
 	linux/serial.h \
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 25ee0f59e62..e5d07813c34 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -60,8 +60,8 @@
 #ifdef HAVE_KQUEUE
 # include <sys/event.h>
 #endif
-#ifdef HAVE_LINUX_NTSYNC_H
-# include <linux/ntsync.h>
+#ifdef HAVE_LINUX_TYPES_H
+# include "ntsync.h"
 #endif
 
 #include "ntstatus.h"
diff --git a/include/Makefile.in b/include/Makefile.in
index 37d4af0f82f..d8efa97ec2c 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -598,6 +598,7 @@ SOURCES = \
 	ntsecapi.h \
 	ntsecpkg.h \
 	ntstatus.h \
+	ntsync.h \
 	ntuser.h \
 	oaidl.idl \
 	objbase.h \
diff --git a/include/ntsync.h b/include/ntsync.h
new file mode 100644
index 00000000000..7d85cb82ca5
--- /dev/null
+++ b/include/ntsync.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Kernel support for NT synchronization primitive emulation
+ *
+ * Copyright (C) 2021-2022 Elizabeth Figura <zfigura@codeweavers.com>
+ */
+
+#ifndef __LINUX_NTSYNC_H
+#define __LINUX_NTSYNC_H
+
+#include <linux/types.h>
+
+struct ntsync_sem_args {
+	__u32 count;
+	__u32 max;
+};
+
+struct ntsync_mutex_args {
+	__u32 owner;
+	__u32 count;
+};
+
+struct ntsync_event_args {
+	__u32 manual;
+	__u32 signaled;
+};
+
+#define NTSYNC_WAIT_REALTIME	0x1
+
+struct ntsync_wait_args {
+	__u64 timeout;
+	__u64 objs;
+	__u32 count;
+	__u32 index;
+	__u32 flags;
+	__u32 owner;
+	__u32 alert;
+	__u32 pad;
+};
+
+#define NTSYNC_MAX_WAIT_COUNT 64
+
+#define NTSYNC_IOC_CREATE_SEM		_IOW ('N', 0x80, struct ntsync_sem_args)
+#define NTSYNC_IOC_WAIT_ANY		_IOWR('N', 0x82, struct ntsync_wait_args)
+#define NTSYNC_IOC_WAIT_ALL		_IOWR('N', 0x83, struct ntsync_wait_args)
+#define NTSYNC_IOC_CREATE_MUTEX		_IOW ('N', 0x84, struct ntsync_mutex_args)
+#define NTSYNC_IOC_CREATE_EVENT		_IOW ('N', 0x87, struct ntsync_event_args)
+
+#define NTSYNC_IOC_SEM_RELEASE		_IOWR('N', 0x81, __u32)
+#define NTSYNC_IOC_MUTEX_UNLOCK		_IOWR('N', 0x85, struct ntsync_mutex_args)
+#define NTSYNC_IOC_MUTEX_KILL		_IOW ('N', 0x86, __u32)
+#define NTSYNC_IOC_EVENT_SET		_IOR ('N', 0x88, __u32)
+#define NTSYNC_IOC_EVENT_RESET		_IOR ('N', 0x89, __u32)
+#define NTSYNC_IOC_EVENT_PULSE		_IOR ('N', 0x8a, __u32)
+#define NTSYNC_IOC_SEM_READ		_IOR ('N', 0x8b, struct ntsync_sem_args)
+#define NTSYNC_IOC_MUTEX_READ		_IOR ('N', 0x8c, struct ntsync_mutex_args)
+#define NTSYNC_IOC_EVENT_READ		_IOR ('N', 0x8d, struct ntsync_event_args)
+
+#define HAVE_LINUX_NTSYNC_H
+
+#endif
diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index a2781ac293c..10a4d0e2538 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -33,6 +33,9 @@
 #include "handle.h"
 #include "request.h"
 #include "thread.h"
+#ifdef HAVE_LINUX_TYPES_H
+# include "ntsync.h"
+#endif
 
 #ifdef HAVE_LINUX_NTSYNC_H
 
@@ -40,7 +43,6 @@
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <unistd.h>
-#include <linux/ntsync.h>
 
 struct linux_device
 {
-- 
2.49.0


From d8b8645fb29bb5056d020d99264728bf7e30e248 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Wed, 26 Feb 2025 12:14:30 -0800
Subject: [PATCH 34/37] ntdll: Check for esync/fsync before doing server waits.

---
 dlls/ntdll/unix/file.c    |  7 ++++++-
 dlls/ntdll/unix/process.c |  7 ++++++-
 dlls/ntdll/unix/server.c  |  5 ++++-
 dlls/ntdll/unix/thread.c  | 12 ++++++++++--
 4 files changed, 26 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 0754a931d5a..8ec17ec1591 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -121,6 +121,8 @@
 #include "wine/list.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "fsync.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(file);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
@@ -7038,7 +7040,10 @@ NTSTATUS WINAPI NtLockFile( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void
         }
         if (handle)
         {
-            server_wait_for_object( handle, FALSE, NULL );
+            if (!(do_fsync() || do_esync()))
+                server_wait_for_object( handle, FALSE, NULL );
+            else
+                NtWaitForSingleObject( handle, FALSE, NULL );
             NtClose( handle );
         }
         else  /* Unix lock conflict, sleep a bit and retry */
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 4b1d8e6f1bc..ea3e10e73d9 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -70,6 +70,8 @@
 #include "wine/condrv.h"
 #include "wine/server.h"
 #include "wine/debug.h"
+#include "fsync.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(process);
 
@@ -920,7 +922,10 @@ NTSTATUS WINAPI NtCreateUserProcess( HANDLE *process_handle_ptr, HANDLE *thread_
 
     /* wait for the new process info to be ready */
 
-    server_wait_for_object( process_info, FALSE, NULL );
+    if (!(do_fsync() || do_esync()))
+        server_wait_for_object( process_info, FALSE, NULL );
+    else
+        NtWaitForSingleObject( process_info, FALSE, NULL );
     SERVER_START_REQ( get_new_process_info )
     {
         req->info = wine_server_obj_handle( process_info );
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 80c603068b5..ebdb52e79ca 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -911,7 +911,10 @@ unsigned int server_queue_process_apc( HANDLE process, const union apc_call *cal
         }
         else
         {
-            server_wait_for_object( handle, FALSE, NULL );
+            if (!(do_fsync() || do_esync()))
+                server_wait_for_object( handle, FALSE, NULL );
+            else
+                NtWaitForSingleObject( handle, FALSE, NULL );
 
             SERVER_START_REQ( get_apc_result )
             {
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 95d3a49b1a0..374bbb8f8af 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -76,6 +76,8 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "fsync.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(thread);
 WINE_DECLARE_DEBUG_CHANNEL(seh);
@@ -1671,7 +1673,10 @@ NTSTATUS WINAPI NtSuspendThread( HANDLE handle, ULONG *ret_count )
 
     if (ret == STATUS_PENDING && wait_handle)
     {
-        NtWaitForSingleObject( wait_handle, FALSE, NULL );
+        if ((do_fsync() || do_esync())) // this breaks with ntsync
+            NtWaitForSingleObject( wait_handle, FALSE, NULL );
+        else
+            server_wait_for_object( wait_handle, FALSE, NULL );
 
         SERVER_START_REQ( suspend_thread )
         {
@@ -1846,7 +1851,10 @@ NTSTATUS get_thread_context( HANDLE handle, void *context, BOOL *self, USHORT ma
 
     if (ret == STATUS_PENDING)
     {
-        server_wait_for_object( context_handle, FALSE, NULL );
+        if (!(do_fsync() || do_esync()))
+            server_wait_for_object( context_handle, FALSE, NULL );
+        else
+            NtWaitForSingleObject( context_handle, FALSE, NULL );
 
         SERVER_START_REQ( get_thread_context )
         {
-- 
2.49.0


From 0f3c181044e9c45fa6133749249c32f62eef7fbf Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Fri, 28 Feb 2025 22:55:27 -0800
Subject: [PATCH 35/37] server, ntdll: Add a do_ntsync helper.

Also add WINENTSYNC=0 as a shorthand for WINE_DISABLE_FAST_SYNC=1.
---
 dlls/ntdll/unix/esync.c        |  3 +-
 dlls/ntdll/unix/fsync.c        |  3 +-
 dlls/ntdll/unix/sync.c         | 13 +++++++
 dlls/ntdll/unix/unix_private.h |  1 +
 server/esync.c                 |  3 +-
 server/fsync.c                 |  3 +-
 server/inproc_sync.c           | 64 ++++++++++++++++++++++++----------
 server/main.c                  |  5 +--
 server/object.h                |  1 +
 9 files changed, 66 insertions(+), 30 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 0e924e199bb..b2fef343e51 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -57,8 +57,7 @@ NTSTATUS do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync() &&
-                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
+        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync() && !do_ntsync();
 
     return do_esync_cached;
 #else
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 3736a0808ad..445b90947a2 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -171,8 +171,7 @@ NTSTATUS do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, NULL, 0, 0, NULL, 0 );
-        do_fsync_cached = errno != ENOSYS && !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) &&
-                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
+        do_fsync_cached = errno != ENOSYS && !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) && !do_ntsync();
     }
 
     return do_fsync_cached;
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index e5d07813c34..db6da34b163 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1144,6 +1144,14 @@ static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
     return ret;
 }
 
+NTSTATUS do_ntsync(void)
+{
+    static int do_ntsync_cached = -1;
+    if (do_ntsync_cached == -1)
+        do_ntsync_cached = (get_linux_sync_device() >= 0);
+    return !!do_ntsync_cached;
+}
+
 #else
 
 void close_inproc_sync_obj( HANDLE handle )
@@ -1202,6 +1210,11 @@ static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
     return STATUS_NOT_IMPLEMENTED;
 }
 
+NTSTATUS do_ntsync(void)
+{
+    return 0;
+}
+
 #endif
 
 
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 962a47f436c..7c2b2bd1ef3 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -405,6 +405,7 @@ extern NTSTATUS wow64_wine_spawnvp( void *args );
 extern void dbg_init(void);
 
 extern void close_inproc_sync_obj( HANDLE handle );
+extern NTSTATUS do_ntsync(void);
 
 extern NTSTATUS call_user_apc_dispatcher( CONTEXT *context_ptr, ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
                                           PNTAPCFUNC func, NTSTATUS status );
diff --git a/server/esync.c b/server/esync.c
index fa73a4651ee..abf454ec100 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -51,8 +51,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync() &&
-                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
+        do_esync_cached = !(getenv("WINEESYNC") && !atoi(getenv("WINEESYNC"))) && !do_fsync() && !do_ntsync();
 
     return do_esync_cached;
 #else
diff --git a/server/fsync.c b/server/fsync.c
index d8c5dced58b..04b74dcca23 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -59,8 +59,7 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, 0, 0, 0, 0, 0);
-        do_fsync_cached = errno != ENOSYS && !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) &&
-                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
+        do_fsync_cached = errno != ENOSYS && !(getenv("WINEFSYNC") && !atoi(getenv("WINEFSYNC"))) && !do_ntsync();
     }
 
     return do_fsync_cached;
diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 10a4d0e2538..9562e4fc581 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -126,12 +126,31 @@ static enum server_fd_type inproc_sync_get_fd_type( struct fd *fd )
     return FD_TYPE_FILE;
 }
 
+static int get_ntsync_fd(void)
+{
+    int fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
+    if (fd == -1)
+    {
+        static int once;
+        file_set_error();
+        if (!once++) fprintf( stderr, "Cannot open /dev/ntsync: %s\n", strerror( errno ) );
+        return 0;
+    }
+    return fd;
+}
+
 static struct linux_device *get_linux_device(void)
 {
     struct linux_device *device;
     static int initialized;
     int unix_fd;
 
+    if (!do_ntsync())
+    {
+        set_error( STATUS_NOT_IMPLEMENTED );
+        return NULL;
+    }
+
     if (initialized)
     {
         if (linux_device_object)
@@ -141,24 +160,7 @@ static struct linux_device *get_linux_device(void)
         return linux_device_object;
     }
 
-    if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
-    {
-      static int once;
-        set_error( STATUS_NOT_IMPLEMENTED );
-	if (!once++) fprintf(stderr, "ntsync is explicitly disabled.\n");
-	initialized = 1;
-        return NULL;
-    }
-
-    unix_fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
-    if (unix_fd == -1)
-    {
-      static int once;
-        file_set_error();
-	if (!once++) fprintf(stderr, "Cannot open /dev/ntsync: %s\n", strerror(errno));
-	initialized = 1;
-        return NULL;
-    }
+    if (!(unix_fd = get_ntsync_fd())) return NULL;
 
     if (!(device = alloc_object( &linux_device_ops )))
     {
@@ -181,6 +183,26 @@ static struct linux_device *get_linux_device(void)
     return device;
 }
 
+int do_ntsync(void)
+{
+    static int do_ntsync_cached = -1;
+    if (do_ntsync_cached == -1)
+    {
+        int temp_fd;
+        do_ntsync_cached = 1;
+        if ((getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) )) ||
+            (getenv( "WINENTSYNC" ) && !atoi( getenv( "WINENTSYNC" ) )))
+        {
+            fprintf( stderr, "ntsync is explicitly disabled.\n" );
+            do_ntsync_cached = 0;
+        }
+        /* lightweight permission check, full get_linux_device breaks when done at early startup */
+        else if ((temp_fd = get_ntsync_fd())) close( temp_fd );
+        else do_ntsync_cached = 0;
+    }
+    return do_ntsync_cached;
+}
+
 struct inproc_sync
 {
     struct object obj;
@@ -402,6 +424,12 @@ void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync )
 {
 }
 
+int do_ntsync(void)
+{
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return 0;
+}
+
 #endif
 
 DECL_HANDLER(get_linux_sync_device)
diff --git a/server/main.c b/server/main.c
index d0ac24b0a1f..433e41ee7e1 100644
--- a/server/main.c
+++ b/server/main.c
@@ -231,8 +231,6 @@ int main( int argc, char *argv[] )
 
     sock_init();
     open_master_socket();
-    if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
-    {
 
     if (do_fsync())
         fsync_init();
@@ -240,9 +238,8 @@ int main( int argc, char *argv[] )
     if (do_esync())
         esync_init();
 
-    if (!do_fsync() && !do_esync())
+    if (!do_fsync() && !do_esync() && !do_ntsync())
         fprintf( stderr, "wineserver: using server-side synchronization.\n" );
-    }
 
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
diff --git a/server/object.h b/server/object.h
index 2567f3a07e2..999e4acce70 100644
--- a/server/object.h
+++ b/server/object.h
@@ -245,6 +245,7 @@ extern struct inproc_sync *create_inproc_semaphore( unsigned int count, unsigned
 extern void set_inproc_event( struct inproc_sync *obj );
 extern void reset_inproc_event( struct inproc_sync *obj );
 extern void abandon_inproc_mutex( thread_id_t tid, struct inproc_sync *inproc_sync );
+extern int do_ntsync(void);
 
 extern struct inproc_sync *no_get_inproc_sync( struct object *obj );
 
-- 
2.49.0


From 44699cdac5144f6eaec9d71b36a15c65a7bbb862 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Fri, 4 Apr 2025 20:37:03 +0300
Subject: [PATCH 36/37] ntdll: Make the staging_warn_event a permanent object.

Avoids printing it repeatedly.
---
 dlls/ntdll/loader.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 84df6640bb3..a62f19c1c58 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -4692,7 +4692,7 @@ void loader_init( CONTEXT *context, void **entry )
 {
     OBJECT_ATTRIBUTES staging_event_attr;
     UNICODE_STRING staging_event_string;
-    HANDLE staging_event;
+    HANDLE staging_event = 0;
     static int attach_done;
     NTSTATUS status;
     ULONG_PTR cookie, port = 0;
@@ -4808,7 +4808,7 @@ void loader_init( CONTEXT *context, void **entry )
          * add a comment here to try to prevent that. */
     }
     RtlInitUnicodeString( &staging_event_string, L"\\__wine_staging_warn_event" );
-    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF, NULL, NULL );
+    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF | OBJ_PERMANENT, NULL, NULL );
     if (NtCreateEvent( &staging_event, EVENT_ALL_ACCESS, &staging_event_attr, NotificationEvent, FALSE ) == STATUS_SUCCESS)
     {
         FIXME_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
@@ -4817,6 +4817,8 @@ void loader_init( CONTEXT *context, void **entry )
     else
         WARN_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
 
+    NtClose( staging_event );
+
     NtCurrentTeb()->FlsSlots = fls_alloc_data();
 
     if (!attach_done)  /* first time around */
-- 
2.49.0


From 899de154f052365cfff667989ea8d4b65c466fc2 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Fri, 4 Apr 2025 20:54:26 +0300
Subject: [PATCH 37/37] wine: Consolidate and clean up startup messaging.

---
 dlls/ntdll/loader.c            | 53 ++++++++++++++++++++++++++--------
 dlls/ntdll/ntdll.spec          |  2 ++
 dlls/ntdll/unix/loader.c       |  2 ++
 dlls/ntdll/unix/sync.c         | 27 +++++++++++++++++
 dlls/ntdll/unix/unix_private.h |  2 ++
 dlls/ntdll/unixlib.h           |  1 +
 include/winternl.h             |  2 ++
 server/esync.c                 |  2 --
 server/fsync.c                 |  2 --
 server/inproc_sync.c           |  2 --
 server/main.c                  |  3 --
 11 files changed, 77 insertions(+), 21 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index a62f19c1c58..96825788c85 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -45,6 +45,7 @@ WINE_DECLARE_DEBUG_CHANNEL(snoop);
 WINE_DECLARE_DEBUG_CHANNEL(loaddll);
 WINE_DECLARE_DEBUG_CHANNEL(imports);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
+WINE_DECLARE_DEBUG_CHANNEL(sync);
 
 #ifdef _WIN64
 #define DEFAULT_SECURITY_COOKIE_64  (((ULONGLONG)0x00002b99 << 32) | 0x2ddfa232)
@@ -3665,6 +3666,13 @@ unsigned int CDECL wine_server_call( void *req_ptr )
     return WINE_UNIX_CALL( unix_wine_server_call, req_ptr );
 }
 
+/***********************************************************************
+ *           __wine_get_sync_type
+ */
+NTSTATUS WINAPI __wine_get_sync_type(void)
+{
+    return WINE_UNIX_CALL( unix_wine_get_sync_type, NULL );
+}
 
 /***********************************************************************
  *           wine_server_fd_to_handle
@@ -4690,9 +4698,9 @@ static void release_address_space(void)
  */
 void loader_init( CONTEXT *context, void **entry )
 {
-    OBJECT_ATTRIBUTES staging_event_attr;
-    UNICODE_STRING staging_event_string;
-    HANDLE staging_event = 0;
+    OBJECT_ATTRIBUTES startup_event_attr;
+    UNICODE_STRING startup_event_string;
+    HANDLE startup_event = 0;
     static int attach_done;
     NTSTATUS status;
     ULONG_PTR cookie, port = 0;
@@ -4807,17 +4815,38 @@ void loader_init( CONTEXT *context, void **entry )
         /* This hunk occasionally applies in the wrong place;
          * add a comment here to try to prevent that. */
     }
-    RtlInitUnicodeString( &staging_event_string, L"\\__wine_staging_warn_event" );
-    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF | OBJ_PERMANENT, NULL, NULL );
-    if (NtCreateEvent( &staging_event, EVENT_ALL_ACCESS, &staging_event_attr, NotificationEvent, FALSE ) == STATUS_SUCCESS)
+    if (FIXME_ON(winediag) || FIXME_ON(sync))
     {
-        FIXME_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
-        FIXME_(winediag)("Please mention your exact version when filing bug reports on winehq.org.\n");
+        RtlInitUnicodeString( &startup_event_string, L"\\__wine_startup_event" );
+        InitializeObjectAttributes( &startup_event_attr, &startup_event_string, OBJ_OPENIF | OBJ_PERMANENT, NULL, NULL );
+        if (NtCreateEvent( &startup_event, EVENT_ALL_ACCESS, &startup_event_attr, NotificationEvent, FALSE ) == STATUS_SUCCESS)
+        {
+            if (FIXME_ON(sync))
+            {
+                NTSTATUS sync = __wine_get_sync_type();
+                if (sync < 0)
+                    MESSAGE("ntsync is explicitly disabled.\n");
+                switch (abs(sync))
+                {
+                case 1:
+                    MESSAGE("esync: up and running.\n");
+                    break;
+                case 2:
+                    MESSAGE("fsync: up and running.\n");
+                    break;
+                case 3:
+                    MESSAGE("wine: using fast synchronization.\n");
+                    break;
+                default:
+                    MESSAGE("wineserver: using server-side synchronization.\n");
+                    break;
+                }
+            }
+            if (FIXME_ON(winediag))
+                MESSAGE("winediag: this wine %s contains many experimental patches, please don't report bugs to winehq.org.\n", wine_get_version());
+        }
+        NtClose( startup_event );
     }
-    else
-        WARN_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
-
-    NtClose( staging_event );
 
     NtCurrentTeb()->FlsSlots = fls_alloc_data();
 
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 4ac3ce4dc36..82b7bf8211d 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -1756,6 +1756,8 @@
 @ cdecl -norelay __wine_dbg_strdup(str)
 @ stdcall -syscall -norelay __wine_dbg_ftrace(ptr long long)
 
+@ stdcall __wine_get_sync_type()
+
 # Version
 @ cdecl wine_get_version()
 @ cdecl wine_get_build_id()
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 80b17e17b16..595f72f7651 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -1262,6 +1262,7 @@ static const unixlib_entry_t unix_call_funcs[] =
     unixcall_wine_server_handle_to_fd,
     unixcall_wine_spawnvp,
     system_time_precise,
+    unixcall_wine_get_sync_type,
     steamclient_setup_trampolines,
     is_pc_in_native_so,
     debugstr_pc,
@@ -1308,6 +1309,7 @@ const unixlib_entry_t unix_call_wow64_funcs[] =
     wow64_wine_server_handle_to_fd,
     wow64_wine_spawnvp,
     system_time_precise,
+    unixcall_wine_get_sync_type,
     wow64_steamclient_setup_trampolines,
     is_pc_in_native_so,
     wow64_debugstr_pc,
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index db6da34b163..fd3b94f8cc0 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1218,6 +1218,33 @@ NTSTATUS do_ntsync(void)
 #endif
 
 
+NTSTATUS WINAPI __wine_get_sync_type(void)
+{
+    static NTSTATUS result = STATUS_PENDING;
+    if (result == STATUS_PENDING)
+    {
+        result = STATUS_NO_WORK_DONE; /* server */
+        if (do_ntsync())
+            result = 3;
+        else if (do_fsync())
+            result = 2;
+        else if (do_esync())
+            result = 1;
+        if ((getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) )) ||
+            (getenv( "WINENTSYNC" ) && !atoi( getenv( "WINENTSYNC" ) )))
+            result = -result;
+    }
+    return result;
+}
+
+/***********************************************************************
+ *           unixcall_wine_get_sync_type
+ */
+NTSTATUS unixcall_wine_get_sync_type(void *args)
+{
+    return __wine_get_sync_type();
+}
+
 /******************************************************************************
  *              NtCreateSemaphore (NTDLL.@)
  */
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 7c2b2bd1ef3..9a97565505a 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -407,6 +407,8 @@ extern void dbg_init(void);
 extern void close_inproc_sync_obj( HANDLE handle );
 extern NTSTATUS do_ntsync(void);
 
+extern NTSTATUS unixcall_wine_get_sync_type(void *args);
+
 extern NTSTATUS call_user_apc_dispatcher( CONTEXT *context_ptr, ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
                                           PNTAPCFUNC func, NTSTATUS status );
 extern NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context );
diff --git a/dlls/ntdll/unixlib.h b/dlls/ntdll/unixlib.h
index e0870584a68..b21c4412cba 100644
--- a/dlls/ntdll/unixlib.h
+++ b/dlls/ntdll/unixlib.h
@@ -89,6 +89,7 @@ enum ntdll_unix_funcs
     unix_wine_server_handle_to_fd,
     unix_wine_spawnvp,
     unix_system_time_precise,
+    unix_wine_get_sync_type,
     unix_steamclient_setup_trampolines,
     unix_is_pc_in_native_so,
     unix_debugstr_pc,
diff --git a/include/winternl.h b/include/winternl.h
index be01f3b31d0..4eefd818174 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -5367,6 +5367,8 @@ static inline PLIST_ENTRY RemoveTailList(PLIST_ENTRY le)
 
 NTSYSAPI NTSTATUS WINAPI __wine_unix_spawnvp( char * const argv[], int wait );
 
+NTSYSAPI NTSTATUS WINAPI __wine_get_sync_type(void);
+
 /* The thread information for 16-bit threads */
 /* NtCurrentTeb()->SubSystemTib points to this */
 typedef struct
diff --git a/server/esync.c b/server/esync.c
index abf454ec100..a940ebc7a3a 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -100,8 +100,6 @@ void esync_init(void)
     if (ftruncate( shm_fd, shm_size ) == -1)
         perror( "ftruncate" );
 
-    fprintf( stderr, "esync: up and running.\n" );
-
     atexit( shm_cleanup );
 }
 
diff --git a/server/fsync.c b/server/fsync.c
index 04b74dcca23..df7989b94f6 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -117,8 +117,6 @@ void fsync_init(void)
 
     is_fsync_initialized = 1;
 
-    fprintf( stderr, "fsync: up and running.\n" );
-
     shm_idx_free_map_size = 256;
     shm_idx_free_map = malloc( shm_idx_free_map_size * sizeof(*shm_idx_free_map) );
     memset( shm_idx_free_map, 0xff, shm_idx_free_map_size * sizeof(*shm_idx_free_map) );
diff --git a/server/inproc_sync.c b/server/inproc_sync.c
index 9562e4fc581..b0136fc7481 100644
--- a/server/inproc_sync.c
+++ b/server/inproc_sync.c
@@ -177,7 +177,6 @@ static struct linux_device *get_linux_device(void)
         return NULL;
     }
 
-    fprintf( stderr, "wine: using fast synchronization.\n" );
     linux_device_object = device;
     initialized = 1;
     return device;
@@ -193,7 +192,6 @@ int do_ntsync(void)
         if ((getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) )) ||
             (getenv( "WINENTSYNC" ) && !atoi( getenv( "WINENTSYNC" ) )))
         {
-            fprintf( stderr, "ntsync is explicitly disabled.\n" );
             do_ntsync_cached = 0;
         }
         /* lightweight permission check, full get_linux_device breaks when done at early startup */
diff --git a/server/main.c b/server/main.c
index 433e41ee7e1..e2129002fd2 100644
--- a/server/main.c
+++ b/server/main.c
@@ -238,9 +238,6 @@ int main( int argc, char *argv[] )
     if (do_esync())
         esync_init();
 
-    if (!do_fsync() && !do_esync() && !do_ntsync())
-        fprintf( stderr, "wineserver: using server-side synchronization.\n" );
-
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
     init_signals();
-- 
2.49.0

